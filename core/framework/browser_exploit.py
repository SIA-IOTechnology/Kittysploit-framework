from core.framework.browser_auxiliary import BrowserAuxiliary
from core.framework.exploit_base import ExploitBase
from core.framework.failure import ProcedureError, FailureType
from core.output_handler import print_info, print_success, print_error, print_warning, print_status


class BrowserExploit(BrowserAuxiliary, ExploitBase):
    """
    Base class for browser exploit modules.
    Combines BrowserAuxiliary (JavaScript injection) with ExploitBase (payload/listener management).
    """

    TYPE_MODULE = "browserexploit"

    def __init__(self, framework=None):
        # Initialize BrowserAuxiliary first (which initializes BaseModule)
        BrowserAuxiliary.__init__(self, framework)
        # Initialize ExploitBase attributes (BaseModule already initialized)
        # We only need to set the listener-related attributes
        self.type = "exploit"  # Mark as exploit for compatible_payloads command
        self.active_listener = None
        self.listener_thread = None
        self.listener_running = False
        self.listener_module = None
        self.listener_config = {}
        self.payload_type = None
        self.session_type = None

    
    def _add_payload_option(self, payload_path):
        """Add payload options to the exploit module, adapting based on handler type"""
        try:
            from core.utils.function import pythonize_path
            from core.framework.enums import Handler
            import importlib
            
            # Load payload module
            payload_path_normalized = pythonize_path(payload_path)
            module_path = ".".join(("modules", payload_path_normalized))
            payload_module = getattr(importlib.import_module(module_path), "Module")()
            
            # Set framework reference
            if self.framework:
                payload_module.framework = self.framework
            
            # Detect handler type from payload
            handler_type = None
            if hasattr(payload_module, '__info__') and payload_module.__info__:
                handler_info = payload_module.__info__.get('handler')
                if handler_info:
                    if hasattr(handler_info, 'value'):
                        handler_type = handler_info.value
                    elif hasattr(handler_info, 'name'):
                        handler_type = handler_info.name.lower()
                    else:
                        handler_type = str(handler_info).lower()
            
            # Copy payload options to exploit instance, adapting based on handler type
            # Get exploit_attributes from the class, not the instance
            payload_options = getattr(payload_module.__class__, 'exploit_attributes', {})
            if not payload_options:
                # Fallback to instance if class doesn't have it
                payload_options = getattr(payload_module, 'exploit_attributes', {})
            
            # Determine which options to add based on handler type
            handler_specific_options = []
            if handler_type == 'reverse':
                # For reverse shells, add lhost and lport options
                handler_specific_options = ['lhost', 'lport']
            elif handler_type == 'bind':
                # For bind shells, add rhost and rport options
                handler_specific_options = ['rhost', 'rport']
            
            # Add handler-specific options first
            for option_name in handler_specific_options:
                if option_name in payload_options and not hasattr(self, option_name):
                    option_data = payload_options[option_name]
                    if len(option_data) >= 4:
                        from core.framework.option.option_string import OptString
                        from core.framework.option.option_port import OptPort
                        
                        default_value = option_data[0] if option_data[0] else ""
                        if option_name in ['lport', 'rport']:
                            opt = OptPort(
                                int(default_value) if default_value and default_value.isdigit() else 4444,
                                option_data[2],
                                option_data[1],
                                option_data[3]
                            )
                        else:
                            opt = OptString(
                                default_value,
                                option_data[2],
                                option_data[1],
                                option_data[3]
                            )
                        setattr(self.__class__, option_name, opt)
                        # Update exploit_attributes manually
                        if not hasattr(self.__class__, 'exploit_attributes'):
                            self.__class__.exploit_attributes = {}
                        opt.label = option_name
                        display_value = getattr(opt, '_default_display_value', str(getattr(opt, '_default_value', '')))
                        self.__class__.exploit_attributes[option_name] = [
                            display_value,
                            option_data[1],
                            option_data[2],
                            option_data[3]
                        ]
            
            # Add other payload options (like encoder, etc.) that are not handler-specific
            for option_name, option_data in payload_options.items():
                if option_name not in handler_specific_options and not hasattr(self, option_name):
                    if len(option_data) >= 4:
                        from core.framework.option.option_string import OptString
                        from core.framework.option.option_port import OptPort
                        
                        default_value = option_data[0] if option_data[0] else ""
                        # Try to detect port options
                        if 'port' in option_name.lower() and default_value and default_value.isdigit():
                            opt = OptPort(
                                int(default_value),
                                option_data[2],
                                option_data[1],
                                option_data[3]
                            )
                        else:
                            opt = OptString(
                                default_value,
                                option_data[2],
                                option_data[1],
                                option_data[3]
                            )
                        setattr(self.__class__, option_name, opt)
                        # Update exploit_attributes manually
                        if not hasattr(self.__class__, 'exploit_attributes'):
                            self.__class__.exploit_attributes = {}
                        opt.label = option_name
                        display_value = getattr(opt, '_default_display_value', str(getattr(opt, '_default_value', '')))
                        self.__class__.exploit_attributes[option_name] = [
                            display_value,
                            option_data[1],
                            option_data[2],
                            option_data[3]
                        ]
            
            return payload_module
        
        except Exception as e:
            print_error(f"Error adding payload option: {e}")
            return None
    
    def check(self):
        """Check if the target is vulnerable"""
        raise NotImplementedError("BrowserExploit modules must implement the check() method")
    
    def run(self):
        """
        Run the exploit - must be implemented by derived classes.
        This method should generate and send the payload via JavaScript.
        """
        raise NotImplementedError("BrowserExploit modules must implement the run() method")
    
    def _exploit(self):
        """Execute the exploit with automatic listener management and JavaScript injection"""
        try:
            # Ensure browser server is available
            self._ensure_browser_server()
            if not self.browser_server:
                print_error("Browser server not available. Start it with 'browser_server start'")
                return False
            
            # Check session exists
            if not self.session_id:
                print_error("No session ID specified. Use 'set session_id <id>' to set a target session.")
                return False
            
            session = self.browser_server.get_session(self.session_id)
            if not session:
                print_error(f"Session {self.session_id[:8]}... not found")
                return False
            
            # Check fingerprint match if required
            if not self._check_fingerprint_match():
                print_error("Fingerprint match failed")
                return False
            
            # Require a payload to be set (check path, not generated payload)
            # Access the OptPayload descriptor via the class to avoid triggering __get__()
            payload_path_value = None
            payload_option = getattr(type(self), 'payload', None)
            if payload_option and hasattr(payload_option, '_instance_values'):
                instance_id = id(self)
                if instance_id in payload_option._instance_values:
                    payload_path_value = payload_option._instance_values[instance_id].get('value')
            
            if not payload_path_value and payload_option:
                if hasattr(payload_option, '_default_value'):
                    payload_path_value = payload_option._default_value
            
            if not payload_path_value:
                print_error("No payload specified. Use 'set payload <path>' to set a payload.")
                return False
            
            # Extract listener information from payload
            listener_info = self._extract_listener_from_payload()
            if not listener_info:
                print_error("Failed to extract listener information from payload")
                return False
                
            self.listener_module = listener_info['listener']
            self.payload_type = listener_info['handler']
            self.session_type = listener_info.get('session_type', 'shell')
            print_status(f"Using listener from payload: {self.listener_module}")
            print_status(f"Handler type: {self.payload_type}")
            
            # Start listener if needed (only if disablePayloadHandler is False)
            if not self.disablePayloadHandler:
                if not self._start_automatic_listener():
                    print_error("Failed to start listener")
                    return False
            
            # Get generated payload (self.payload already handles generation)
            generated_payload = self.payload
            if not generated_payload:
                print_error("Failed to generate payload")
                return False
            
            print_status(f"Generated payload ({len(generated_payload)} bytes)")
            
            # Run the actual exploit (should send payload via JavaScript)
            result = self.run()
            
            if not result:
                print_error("Exploit execution failed")
                return False
            
            # Wait for connection if using reverse payload
            # This will block until a connection is received or timeout is reached
            if self.payload_type == "reverse" and self.listener_running:
                print_status("Waiting for connection...")
                self._wait_for_connection()
            
            return result
            
        except ProcedureError as e:
            raise e
        except Exception as e:
            print_error(f"Error during exploit execution: {e}")
            raise ProcedureError(f"Error during exploit execution: {e}")
        finally:
            # Clean up listener if needed
            if self.listener_running:
                if getattr(self, '_session_received', False) or self._listener_has_active_sessions():
                    print_success("Active session detected - listener will remain running. Stop it manually when you're done.")
                else:
                    self._stop_listener()
    
    
