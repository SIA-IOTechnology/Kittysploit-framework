from core.framework.browser_auxiliary import BrowserAuxiliary
from core.framework.exploit_base import ExploitBase
from core.framework.failure import ProcedureError, FailureType
from core.output_handler import print_info, print_success, print_error, print_warning

class BrowserExploit(BrowserAuxiliary, ExploitBase):
    """
    Base class for browser exploit modules.
    Combines BrowserAuxiliary (JavaScript injection) with ExploitBase (payload/listener management).
    """

    TYPE_MODULE = "browserexploit"

    def __init__(self, framework=None):
        # Initialize BrowserAuxiliary first (which initializes BaseModule)
        BrowserAuxiliary.__init__(self, framework)
        # Initialize ExploitBase attributes (BaseModule already initialized)
        # We only need to set the listener-related attributes
        self.active_listener = None
        self.listener_thread = None
        self.listener_running = False
        self.listener_module = None
        self.listener_config = {}
        self.payload_type = None
        self.session_type = None

    
    def _add_payload_option(self, payload_path):
        """Add payload options to the exploit module, adapting based on handler type"""
        try:
            from core.utils.function import pythonize_path
            from core.framework.enums import Handler
            import importlib
            
            # Load payload module
            payload_path_normalized = pythonize_path(payload_path)
            module_path = ".".join(("modules", payload_path_normalized))
            payload_module = getattr(importlib.import_module(module_path), "Module")()
            
            # Set framework reference
            if self.framework:
                payload_module.framework = self.framework
            
            # Detect handler type from payload
            handler_type = None
            if hasattr(payload_module, '__info__') and payload_module.__info__:
                handler_info = payload_module.__info__.get('handler')
                if handler_info:
                    if hasattr(handler_info, 'value'):
                        handler_type = handler_info.value
                    elif hasattr(handler_info, 'name'):
                        handler_type = handler_info.name.lower()
                    else:
                        handler_type = str(handler_info).lower()
            
            # Copy payload options to exploit instance, adapting based on handler type
            payload_options = getattr(payload_module, 'exploit_attributes', {})
            
            # Determine which options to add based on handler type
            handler_specific_options = []
            if handler_type == 'reverse':
                # For reverse shells, add lhost and lport options
                handler_specific_options = ['lhost', 'lport']
            elif handler_type == 'bind':
                # For bind shells, add rhost and rport options
                handler_specific_options = ['rhost', 'rport']
            
            # Add payload options to exploit instance
            for option in payload_options:
                if option not in handler_specific_options:
                    self.add_option(option, payload_options[option])
            
            return payload_module
        
        except Exception as e:
            print_error(f"Error adding payload option: {e}")
            return None
    
    def check(self):
        """Check if the target is vulnerable"""
        raise NotImplementedError("BrowserExploit modules must implement the check() method")
    
    def run(self):
        """
        Run the exploit - must be implemented by derived classes.
        This method should generate and send the payload via JavaScript.
        """
        raise NotImplementedError("BrowserExploit modules must implement the run() method")
    
    def _exploit(self):
        """Execute the exploit with automatic listener management and JavaScript injection"""
        try:
            # Ensure browser server is available
            self._ensure_browser_server()
            if not self.browser_server:
                print_error("[!] Browser server not available. Start it with 'browser_server start'")
                return False
            
            # Check session exists
            if not self.session_id:
                print_error("[!] No session ID specified. Use 'set session_id <id>' to set a target session.")
                return False
            
            session = self.browser_server.get_session(self.session_id)
            if not session:
                print_error(f"[!] Session {self.session_id[:8]}... not found")
                return False
            
            # Check fingerprint match if required
            if not self._check_fingerprint_match():
                print_error("[!] Fingerprint match failed")
                return False
            
            # Require a payload to be set
            if not self.payload:
                print_error("[!] No payload specified. Use 'set payload <path>' to set a payload.")
                return False
            
            # Extract listener information from payload
            listener_info = self._extract_listener_from_payload()
            if not listener_info:
                print_error("[!] Failed to extract listener information from payload")
                return False
                
            self.listener_module = listener_info['listener']
            self.payload_type = listener_info['handler']
            self.session_type = listener_info.get('session_type', 'shell')
            print_info(f"[*] Using listener from payload: {self.listener_module}")
            print_info(f"[*] Handler type: {self.payload_type}")
            
            # Start listener if needed (only if disablePayloadHandler is False)
            if not self.disablePayloadHandler:
                if not self._start_automatic_listener():
                    print_error("[!] Failed to start listener")
                    return False
            
            # Generate payload
            generated_payload = self._generate_payload()
            if not generated_payload:
                print_error("[!] Failed to generate payload")
                return False
            
            print_info(f"[*] Generated payload ({len(generated_payload)} bytes)")
            
            # Run the actual exploit (should send payload via JavaScript)
            result = self.run()
            
            if not result:
                print_error("[!] Exploit execution failed")
                return False
            
            # Wait for connection if using reverse payload
            if self.payload_type == "reverse" and self.listener_running:
                print_info("[*] Waiting for connection...")
                self._wait_for_connection()
            
            return result
            
        except ProcedureError as e:
            raise e
        except Exception as e:
            print_error(f"[!] Error during exploit execution: {e}")
            raise ProcedureError(FailureType.Unknown, e)
        finally:
            # Clean up listener if needed
            if self.listener_running:
                self._stop_listener()
    
    def _generate_payload(self) -> str:
        """
        Generate the payload using the specified payload module.
        This method loads the payload module and generates the actual payload string.
        
        Returns:
            str: Generated payload string, or None if generation fails
        """
        try:
            if not self.payload:
                return None
            
            # Load the payload module using the framework's module loader
            if self.framework and hasattr(self.framework, 'module_loader'):
                payload_module = self.framework.module_loader.load_module(self.payload, framework=self.framework)
                if not payload_module:
                    print_error(f"[!] Failed to load payload module: {self.payload}")
                    return None
                
                # Set framework reference
                payload_module.framework = self.framework
                
                # Copy handler-specific options from exploit to payload
                if hasattr(payload_module, '__info__') and payload_module.__info__:
                    handler_info = payload_module.__info__.get('handler')
                    handler_type = None
                    if handler_info:
                        if hasattr(handler_info, 'value'):
                            handler_type = handler_info.value
                        elif hasattr(handler_info, 'name'):
                            handler_type = handler_info.name.lower()
                        else:
                            handler_type = str(handler_info).lower()
                    
                    # Copy lhost/lport for reverse shells or rhost/rport for bind shells
                    if handler_type == 'reverse':
                        if hasattr(self, 'lhost'):
                            payload_module.lhost = self.lhost
                        if hasattr(self, 'lport'):
                            payload_module.lport = self.lport
                    elif handler_type == 'bind':
                        if hasattr(self, 'rhost'):
                            payload_module.rhost = self.rhost
                        if hasattr(self, 'rport'):
                            payload_module.rport = self.rport
                
                # Generate the payload
                if hasattr(payload_module, 'generate'):
                    generated = payload_module.generate()
                    return generated
                elif hasattr(payload_module, 'run'):
                    # Some payloads use run() instead of generate()
                    result = payload_module.run()
                    if isinstance(result, str):
                        return result
                    else:
                        print_warning("[~] Payload module run() did not return a string")
                        return None
                else:
                    print_error("[!] Payload module does not have generate() or run() method")
                    return None
            else:
                print_error("[!] Framework module loader not available")
                return None
                
        except Exception as e:
            print_error(f"[!] Error generating payload: {e}")
            return None
    