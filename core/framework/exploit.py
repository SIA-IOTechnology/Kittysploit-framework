from core.framework.exploit_base import ExploitBase
from core.framework.failure import ProcedureError, FailureType
from core.output_handler import print_info, print_error
from core.framework.option.option_string import OptString
from core.framework.option.option_port import OptPort

class Exploit(ExploitBase):
    """Base class for exploit modules with automatic listener management"""

    TYPE_MODULE = "exploit"

    def __init__(self, framework=None):
        super().__init__(framework)
        self.type = "exploit"
    
    def _add_payload_option(self, payload_path):
        """Add payload options to the exploit module, adapting based on handler type"""
        try:
            from core.utils.function import pythonize_path
            from core.framework.enums import Handler
            import importlib
            
            # Load payload module
            payload_path_normalized = pythonize_path(payload_path)
            module_path = ".".join(("modules", payload_path_normalized))
            payload_module = getattr(importlib.import_module(module_path), "Module")()
            
            # Set framework reference
            if self.framework:
                payload_module.framework = self.framework
            
            # Detect handler type from payload
            handler_type = None
            if hasattr(payload_module, '__info__') and payload_module.__info__:
                handler_info = payload_module.__info__.get('handler')
                if handler_info:
                    if hasattr(handler_info, 'value'):
                        handler_type = handler_info.value
                    elif hasattr(handler_info, 'name'):
                        handler_type = handler_info.name.lower()
                    else:
                        handler_type = str(handler_info).lower()
            
            # Copy payload options to exploit instance, adapting based on handler type
            payload_options = getattr(payload_module, 'exploit_attributes', {})
            
            # Determine which options to add based on handler type
            handler_specific_options = []
            if handler_type == 'reverse':
                # For reverse shells, add lhost and lport options
                handler_specific_options = ['lhost', 'lport']
            elif handler_type == 'bind':
                # For bind shells, add rhost and rport options
                handler_specific_options = ['rhost', 'rport']
            
            # Ensure exploit_attributes exists on the class (metaclass may use dict from base)
            cls = self.__class__
            if not hasattr(cls, 'exploit_attributes'):
                cls.exploit_attributes = {}
            else:
                # Work on the actual class dict so options show in "options" table
                cls.exploit_attributes = dict(getattr(cls, 'exploit_attributes', {}))

            def _add_opt_and_attr(option_name, opt, option_data):
                setattr(cls, option_name, opt)
                opt.label = option_name
                display_value = getattr(opt, '_default_display_value', str(getattr(opt, '_default_value', '')))
                cls.exploit_attributes[option_name] = [
                    display_value,
                    option_data[1],
                    option_data[2],
                    option_data[3],
                ]

            # Add handler-specific options first (lhost/lport or rhost/rport)
            for option_name in handler_specific_options:
                if option_name in payload_options and not hasattr(self, option_name):
                    option_data = payload_options[option_name]
                    if len(option_data) >= 4:
                        from core.framework.option.option_string import OptString
                        from core.framework.option.option_port import OptPort
                        default_value = option_data[0] if option_data[0] else ""
                        if option_name in ['lport', 'rport']:
                            default_int = int(default_value) if default_value and str(default_value).isdigit() else 4444
                            opt = OptPort(default_int, option_data[2], option_data[1], option_data[3])
                        else:
                            opt = OptString(default_value or "", option_data[2], option_data[1], option_data[3])
                        _add_opt_and_attr(option_name, opt, option_data)

            # Add other payload options (encoder, etc.) that are not handler-specific
            for option_name, option_data in payload_options.items():
                if option_name not in handler_specific_options and not hasattr(self, option_name):
                    if len(option_data) >= 4:
                        from core.framework.option.option_string import OptString
                        from core.framework.option.option_port import OptPort
                        default_value = option_data[0] if option_data[0] else ""
                        if 'port' in option_name.lower() and default_value and str(default_value).isdigit():
                            opt = OptPort(int(default_value), option_data[2], option_data[1], option_data[3])
                        else:
                            opt = OptString(default_value or "", option_data[2], option_data[1], option_data[3])
                        _add_opt_and_attr(option_name, opt, option_data)

            return payload_module
        except Exception as e:
            return None
    
    def check(self):
        """Check if the exploit can be executed"""
        raise NotImplementedError("Exploit modules must implement the check() method")
    
    def run(self):
        """Run the exploit"""
        raise NotImplementedError("Exploit modules must implement the run() method")
    
    def _exploit(self):
        """Execute the exploit with automatic listener management"""
        try:
            # Require a payload to be set
            if not self.payload:
                print_error("No payload specified. Use 'set payload <path>' to set a payload.")
                return False
            
            # Extract listener information from payload
            listener_info = self._extract_listener_from_payload()
            if not listener_info:
                print_error("Failed to extract listener information from payload")
                return False
                
            self.listener_module = listener_info['listener']
            self.payload_type = listener_info['handler']
            self.session_type = listener_info.get('session_type', 'shell')
            print_info(f"Using listener from payload: {self.listener_module}")
            print_info(f"Handler type: {self.payload_type}")
            
            # Start listener if needed (only if disablePayloadHandler is False)
            if not self.disablePayloadHandler:
                if not self._start_automatic_listener():
                    print_error("Failed to start listener")
                    return False
            
            # Run the actual exploit
            result = self.run()
            
            # Wait for connection if using reverse payload
            if self.payload_type == "reverse" and self.listener_running:
                print_info("Waiting for connection...")
                self._wait_for_connection()
            
            return result
            
        except ProcedureError as e:
            raise e
        except Exception as e:
            raise ProcedureError(FailureType.Unknown, e)
        finally:
            # Clean up listener if needed
            if self.listener_running:
                self._stop_listener()