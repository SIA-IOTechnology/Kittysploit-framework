#!/usr/bin/env python3
# -*- coding: utf-8 -*-

"""
Base class for exploit modules with automatic listener management.
This class contains common functionality shared between Exploit and BrowserExploit.
"""

from typing import Any
import importlib
from core.framework.base_module import BaseModule
from core.framework.failure import ProcedureError, FailureType
from core.framework.option.option_payload import OptPayload
from core.framework.option.option_integer import OptInteger
from core.framework.option.option_bool import OptBool
from core.framework.option.option_string import OptString
from core.output_handler import print_info, print_success, print_error, print_warning, print_status
import threading
import time


class ExploitBase(BaseModule):
    """
    Base class for exploit modules with automatic listener management.
    Contains common functionality for payload handling and listener management.
    """

    payload = OptPayload("", "Payload module to use (e.g., payloads/stagers/linux/x64/reverse_tcp)", required=True, advanced=False)
    exploit_timeout = OptInteger(60, "Exploit timeout in seconds", required=True, advanced=True)
    disablePayloadHandler = OptBool(False, "Disable payload handler", required=True, advanced=True)
    obfuscator = OptString("", "Obfuscator module - same for listener and payload (e.g. obfuscators/python/stream/xor)", False, advanced=True)

    def __init__(self, framework=None):
        super().__init__(framework)
        
        # Listener management
        self.active_listener = None
        self.listener_thread = None
        self.listener_running = False
        self.listener_module = None
        self.listener_config = {}
        self.payload_type = None
        self.session_type = None
        self._session_received = False
        
        # Obfuscator: keep a loaded instance when obfuscator path is set (for options display/set and propagation to listener/payload)
        self._obfuscator_instance = None
        self._obfuscator_path = ""
        
        # Load default payload from __info__ if available and no payload is set
        self._load_default_payload()

    def _get_obfuscator_path(self) -> str:
        """Return current obfuscator option value (module path)."""
        obf = getattr(self, "obfuscator", None)
        if obf is None:
            return ""
        path = getattr(obf, "value", obf) if hasattr(obf, "value") else obf
        return (path or "").strip()

    def _ensure_obfuscator_loaded(self) -> None:
        """Load or reload obfuscator instance when obfuscator option is set."""
        path_str = self._get_obfuscator_path()
        if not path_str:
            self._obfuscator_instance = None
            self._obfuscator_path = ""
            return
        if self._obfuscator_instance is not None and self._obfuscator_path == path_str:
            return
        try:
            mod_path = "modules." + path_str.replace("/", ".")
            mod = importlib.import_module(mod_path)
            obf_cls = getattr(mod, "Module", None)
            if not obf_cls:
                self._obfuscator_instance = None
                self._obfuscator_path = ""
                return
            self._obfuscator_instance = obf_cls(framework=getattr(self, "framework", None))
            self._obfuscator_path = path_str
        except Exception:
            self._obfuscator_instance = None
            self._obfuscator_path = ""

    def get_options(self) -> dict:
        """Return exploit options merged with obfuscator options when obfuscator is set."""
        opts = super().get_options()
        path_str = self._get_obfuscator_path()
        if not path_str:
            return opts
        self._ensure_obfuscator_loaded()
        if self._obfuscator_instance is None:
            return opts
        obf_opts = self._obfuscator_instance.get_options()
        if obf_opts:
            merged = dict(opts)
            for name, data in obf_opts.items():
                merged[name] = data
            return merged
        return opts

    def set_option(self, name: str, value: Any) -> bool:
        """Set option on exploit or on obfuscator instance when applicable."""
        own_opts = getattr(self, "exploit_attributes", {})
        if name in own_opts:
            return super().set_option(name, value)
        self._ensure_obfuscator_loaded()
        if self._obfuscator_instance is not None:
            obf_opts = self._obfuscator_instance.get_options()
            if name in obf_opts:
                return self._obfuscator_instance.set_option(name, value)
        return False

    def __getattr__(self, name: str) -> Any:
        """Delegate attribute access to obfuscator instance for obfuscator option names."""
        if name.startswith("_"):
            raise AttributeError(name)
        self._ensure_obfuscator_loaded()
        if self._obfuscator_instance is not None and name in self._obfuscator_instance.get_options():
            return getattr(self._obfuscator_instance, name)
        raise AttributeError(f"'{type(self).__name__}' object has no attribute '{name}'")

    def _load_default_payload(self):
        """Load default payload from __info__ if available and no payload is set"""
        try:
            # Only load default if payload is not already set (empty string or None)
            payload_value = None
            if hasattr(self, 'payload'):
                if hasattr(self.payload, 'value'):
                    payload_value = self.payload.value
                else:
                    payload_value = self.payload
            
            if payload_value and isinstance(payload_value, str) and payload_value.strip():
                return
            
            # Check if __info__ contains a default payload
            if hasattr(self, '__info__') and self.__info__:
                payload_info = self.__info__.get('payload')
                if payload_info and isinstance(payload_info, dict):
                    default_payload = payload_info.get('default')
                    if default_payload and default_payload.strip():
                        try:
                            # Set the default payload - this will trigger _add_payload_option
                            if hasattr(self.payload, '__set__'):
                                self.payload.__set__(self, default_payload)
                            elif hasattr(self.payload, 'value'):
                                self.payload.value = default_payload
                            else:
                                self.payload = default_payload
                            print_status(f"Loaded default payload: {default_payload}")
                        except Exception as e:
                            # If payload loading fails, just warn but don't fail
                            print_warning(f"Failed to load default payload '{default_payload}': {e}")
                            print_warning("You can manually set a payload using 'set payload <path>'")
        except Exception as e:
            # Silently fail - default payload loading is optional
            pass

    def _extract_listener_from_payload(self):
        """Extract listener information from the specified payload module"""
        try:
            # Get the payload path from the option, not the generated payload
            # Access the option descriptor via the class to avoid triggering __get__()
            payload_path_value = None
            
            # Get the OptPayload descriptor from the class (not instance)
            payload_option = getattr(type(self), 'payload', None)
            if payload_option and hasattr(payload_option, '_instance_values'):
                instance_id = id(self)
                if instance_id in payload_option._instance_values:
                    payload_path_value = payload_option._instance_values[instance_id].get('value')
            
            # Fallback to default value if instance value not found
            if not payload_path_value and payload_option:
                if hasattr(payload_option, '_default_value'):
                    payload_path_value = payload_option._default_value
            
            if not payload_path_value:
                return None
                
            # Load the payload module using the framework's module loader
            if self.framework and hasattr(self.framework, 'module_loader'):
                payload_module = self.framework.module_loader.load_module(payload_path_value, framework=self.framework)
                if payload_module and hasattr(payload_module, '__info__'):
                    payload_info = payload_module.__info__
                    
                    # Extract listener and handler information
                    listener_info = {
                        'listener': payload_info.get('listener'),
                        'handler': payload_info.get('handler'),
                        'session_type': payload_info.get('session_type', 'shell'),
                        'protocol': payload_info.get('protocol', 'tcp')
                    }
                    
                    # Convert handler enum to string if needed
                    if hasattr(listener_info['handler'], 'value'):
                        listener_info['handler'] = listener_info['handler'].value
                    elif hasattr(listener_info['handler'], 'name'):
                        listener_info['handler'] = listener_info['handler'].name.lower()
                    
                    return listener_info
                else:
                    print_error(f"Failed to load payload module: {payload_path_value}")
                    return None
            else:
                print_warning("Framework module loader not available, using fallback")
                return None
                
        except Exception as e:
            print_error(f"Error extracting listener from payload: {e}")
            return None

    def is_payload_compatible(self, payload_module):
        """Check if a payload is compatible with this exploit"""
        try:
            if not payload_module or not hasattr(payload_module, '__info__'):
                return False
                
            payload_info = payload_module.__info__
            exploit_info = self.__info__
            
            # Check architecture compatibility
            exploit_archs = exploit_info.get('arch', [])
            if exploit_archs:
                payload_arch = payload_info.get('arch')
                if payload_arch:
                    arch_value = payload_arch.value if hasattr(payload_arch, 'value') else str(payload_arch)
                    if arch_value not in [arch.value if hasattr(arch, 'value') else str(arch) for arch in exploit_archs]:
                        return False
            
            # Check platform compatibility
            exploit_platforms = exploit_info.get('platform', [])
            if exploit_platforms:
                payload_platform = payload_info.get('platform')
                if payload_platform:
                    platform_value = payload_platform.value if hasattr(payload_platform, 'value') else str(payload_platform)
                    if platform_value not in [platform.value if hasattr(platform, 'value') else str(platform) for platform in exploit_platforms]:
                        return False
            
            # Check handler compatibility
            exploit_handlers = exploit_info.get('handler', [])
            if exploit_handlers:
                payload_handler = payload_info.get('handler')
                if payload_handler:
                    handler_value = payload_handler.value if hasattr(payload_handler, 'value') else str(payload_handler)
                    if handler_value not in [handler.value if hasattr(handler, 'value') else str(handler) for handler in exploit_handlers]:
                        return False
            
            # Check session type compatibility
            exploit_session_types = exploit_info.get('session_type', [])
            if exploit_session_types:
                payload_session_type = payload_info.get('session_type')
                if payload_session_type:
                    session_value = payload_session_type.value if hasattr(payload_session_type, 'value') else str(payload_session_type)
                    if session_value not in [session.value if hasattr(session, 'value') else str(session) for session in exploit_session_types]:
                        return False
            
            # Check protocol compatibility
            exploit_protocols = exploit_info.get('protocol', [])
            if exploit_protocols:
                payload_protocol = payload_info.get('protocol')
                if payload_protocol:
                    protocol_value = payload_protocol.value if hasattr(payload_protocol, 'value') else str(payload_protocol)
                    if protocol_value not in [protocol.value if hasattr(protocol, 'value') else str(protocol) for protocol in exploit_protocols]:
                        return False
            
            return True
            
        except Exception as e:
            print_error(f"Error checking payload compatibility: {e}")
            return False

    def get_compatible_payloads(self, framework=None):
        """Get list of compatible payloads for this exploit"""
        try:
            if not framework or not hasattr(framework, 'module_loader'):
                print_warning("Framework module loader not available")
                return []
            
            compatible_payloads = []
            all_payloads = framework.module_loader.get_modules_by_type('payload')
            
            for payload_path, payload_module in all_payloads.items():
                if self.is_payload_compatible(payload_module):
                    compatible_payloads.append({
                        'path': payload_path,
                        'name': payload_module.__info__.get('name', 'Unknown'),
                        'description': payload_module.__info__.get('description', ''),
                        'arch': payload_module.__info__.get('arch'),
                        'platform': payload_module.__info__.get('platform'),
                        'handler': payload_module.__info__.get('handler'),
                        'session_type': payload_module.__info__.get('session_type')
                    })
            
            return compatible_payloads
            
        except Exception as e:
            print_error(f"Error getting compatible payloads: {e}")
            return []

    def _start_automatic_listener(self):
        """Automatically start the appropriate listener based on payload type"""
        try:
            # Reset tracking for newly started listener
            self._session_received = False
            if self.payload_type == "reverse":
                return self._start_reverse_listener()
            elif self.payload_type == "bind":
                return self._start_bind_listener()
            else:
                print_error("Invalid payload type. Must be 'reverse' or 'bind'")
                return False
        except Exception as e:
            print_error(f"Failed to start automatic listener: {e}")
            return False

    def _start_reverse_listener(self):
        """Start a reverse listener"""
        try:
            # Listener should be defined by payload
            if not self.listener_module:
                print_error("No listener module defined. Please set a payload first.")
                return False
            
            # Check if lhost and lport are set
            if not hasattr(self, 'lhost') or not self.lhost:
                print_error("lhost not set. Please set lhost option.")
                return False
            if not hasattr(self, 'lport') or not self.lport:
                print_error("lport not set. Please set lport option.")
                return False
                
            listener_module = self.listener_module
            
            print_info(f"Starting reverse listener: {listener_module}")
            print_info(f"Listening on {self.lhost}:{self.lport}")
            
            # Load and configure the listener
            success = self._load_and_configure_listener(listener_module)
            if not success:
                return False
            
            # Start listener in background thread
            self.listener_thread = threading.Thread(target=self._run_listener, daemon=True)
            self.listener_thread.start()
            
            # Wait a moment for listener to start
            time.sleep(1)
            
            self.listener_running = True
            print_success("Reverse listener started successfully")
            return True
            
        except Exception as e:
            print_error(f"Failed to start reverse listener: {e}")
            return False

    def _start_bind_listener(self):
        """Start a bind listener"""
        try:
            # Listener should be defined by payload
            if not self.listener_module:
                print_error("No listener module defined. Please set a payload first.")
                return False
            
            # Check if rhost and rport are set
            if not hasattr(self, 'rhost') or not self.rhost:
                print_error("rhost not set. Please set rhost option.")
                return False
            if not hasattr(self, 'rport') or not self.rport:
                print_error("rport not set. Please set rport option.")
                return False
                
            listener_module = self.listener_module
            
            print_info(f"Starting bind listener: {listener_module}")
            print_info(f"Target: {self.rhost}:{self.rport}")
            
            # Load and configure the listener
            success = self._load_and_configure_listener(listener_module)
            if not success:
                return False
            
            # Start listener in background thread
            self.listener_thread = threading.Thread(target=self._run_listener, daemon=True)
            self.listener_thread.start()
            
            # Wait a moment for listener to start
            time.sleep(1)
            
            self.listener_running = True
            print_success("Bind listener started successfully")
            return True
            
        except Exception as e:
            print_error(f"Failed to start bind listener: {e}")
            return False

    def _get_payload_platform(self):
        """Get platform string ('windows'/'linux'/None) from current payload module __info__ without generating payload."""
        try:
            payload_opt = getattr(type(self), 'payload', None)
            if not payload_opt or not hasattr(payload_opt, '_instance_values'):
                return None
            instance_id = id(self)
            payload_path = (payload_opt._instance_values.get(instance_id) or {}).get('value') or getattr(payload_opt, '_default_value', None)
            if not payload_path or not isinstance(payload_path, str) or not payload_path.strip():
                return None
            from core.utils.function import pythonize_path
            import importlib
            path = pythonize_path(payload_path.strip())
            mod = importlib.import_module("modules." + path.replace("/", "."))
            info = getattr(getattr(mod, "Module", None), "__info__", None) if hasattr(mod, "Module") else None
            if not info or 'platform' not in info:
                return None
            pl = info['platform']
            if hasattr(pl, 'value'):
                return pl.value
            if hasattr(pl, 'name'):
                return pl.name.lower()
            return str(pl).lower()
        except Exception:
            return None

    def _load_and_configure_listener(self, listener_module):
        """Load and configure the listener module using new generic approach"""
        try:
            # Load the listener module using the framework's module loader
            if self.framework and hasattr(self.framework, 'module_loader'):
                # Get the listener instance from the module
                self.active_listener = self.framework.module_loader.load_module(listener_module, framework=self.framework)
                if self.active_listener:
                    
                    # Configure listener options
                    # Accessing self.lhost/lport via __get__ returns the actual value
                    if hasattr(self, 'lhost') and self.lhost:
                        self.active_listener.lhost = self.lhost
                    if hasattr(self, 'lport') and self.lport:
                        self.active_listener.lport = self.lport
                    if hasattr(self, 'rhost') and self.rhost:
                        self.active_listener.rhost = self.rhost
                    if hasattr(self, 'rport') and self.rport:
                        self.active_listener.rport = self.rport
                    if self.session_type:
                        self.active_listener.session_type = self.session_type
                    if self.payload_type:
                        self.active_listener.handler = self.payload_type
                    # Propagate obfuscator (path + options) to listener so run exploit uses same obfuscation
                    obf_path = self._get_obfuscator_path()
                    if obf_path and hasattr(self.active_listener, 'set_option'):
                        self.active_listener.set_option('obfuscator', obf_path)
                        self._ensure_obfuscator_loaded()
                        if self._obfuscator_instance is not None:
                            for opt_name in self._obfuscator_instance.get_options():
                                if hasattr(self, opt_name):
                                    try:
                                        self.active_listener.set_option(opt_name, getattr(self, opt_name))
                                    except Exception:
                                        pass
                    # Propagate payload platform so session/shell can show correct prompt without sending detection commands
                    payload_platform = self._get_payload_platform()
                    if payload_platform:
                        self.active_listener.session_platform = payload_platform
                    
                    # Debug: Verify configured values after setting
                    configured_lhost = getattr(self.active_listener, 'lhost', None)
                    configured_lport = getattr(self.active_listener, 'lport', None)
                    
                    # Store configuration
                    self.listener_module = listener_module
                    self.listener_config = {
                        "lhost": getattr(self, 'lhost', None),
                        "lport": getattr(self, 'lport', None),
                        "rhost": getattr(self, 'rhost', None),
                        "rport": getattr(self, 'rport', None),
                        "session_type": self.session_type,
                        "handler": self.payload_type
                    }
                    return True
                else:
                    print_error(f"Failed to load listener module: {listener_module}")
                    return False
            else:
                # Fallback: simulate listener configuration
                self.listener_module = listener_module
                self.listener_config = {
                    "lhost": getattr(self, 'lhost', None),
                    "lport": getattr(self, 'lport', None),
                    "rhost": getattr(self, 'rhost', None),
                    "rport": getattr(self, 'rport', None),
                    "session_type": self.session_type,
                    "handler": self.payload_type
                }
                return True
        except Exception as e:
            print_error(f"Failed to load listener module: {e}")
            return False

    def _run_listener(self):
        """Run the listener in background thread using new generic approach"""
        try:
            if not self.active_listener:
                print_error("No active listener instance available")
                self.listener_running = False
                return
            
            # Verify listener is configured before starting
            configured_lhost = getattr(self.active_listener, 'lhost', None)
            configured_lport = getattr(self.active_listener, 'lport', None)
            print_status(f"Starting listener {self.listener_module}...")
            print_status(f"Listener configuration - lhost: {configured_lhost}, lport: {configured_lport}")
            
            # Start the listener (it will run in its own thread and handle sessions automatically)
            if hasattr(self.active_listener, 'start'):
                success = self.active_listener.start()
                if not success:
                    print_error("Failed to start listener - start() returned False")
                    self.listener_running = False
                    return
                
                # Verify listener is actually running
                if hasattr(self.active_listener, 'running'):
                    if self.active_listener.running:
                        print_success("Listener is running (running=True)")
                    else:
                        print_warning("Listener is not running (running=False)")
                elif hasattr(self.active_listener, 'is_running'):
                    if self.active_listener.is_running():
                        print_success("Listener is running (is_running()=True)")
                    else:
                        print_warning("Listener is not running (is_running()=False)")
                else:
                    print_info("Cannot verify listener running status (no running/is_running attribute)")
            else:
                # Fallback: use run_with_auto_session if start() is not available
                print_warning("Listener does not have start() method, trying run_with_auto_session()...")
                if hasattr(self.active_listener, 'run_with_auto_session'):
                    session_id = self.active_listener.run_with_auto_session()
                    if session_id:
                        print_success(f"Listener started successfully with session {session_id}")
                    else:
                        print_error("Failed to start listener - run_with_auto_session() returned None")
                        self.listener_running = False
                        return
                else:
                    print_error("Listener does not support start() or run_with_auto_session()")
                    self.listener_running = False
                    return
            
            # Monitor listener status - keep running until explicitly stopped
            while self.listener_running:
                # Check if listener is still running
                if hasattr(self.active_listener, 'running'):
                    if not self.active_listener.running:
                        # Listener stopped itself (e.g., due to error)
                        print_warning("Listener stopped unexpectedly (running=False)")
                        break
                elif hasattr(self.active_listener, 'is_running'):
                    if not self.active_listener.is_running():
                        print_warning("Listener stopped unexpectedly (is_running()=False)")
                        break
                
                time.sleep(1)
            
            print_status("Listener monitoring loop ended")
            # Stop listener if needed
            if hasattr(self.active_listener, 'stop'):
                print_status("Stopping listener...")
                self.active_listener.stop()
            else:
                # Fallback: simulate listener
                print_status(f"Listener {self.listener_module} running...")
                while self.listener_running:
                    time.sleep(1)
                
        except Exception as e:
            print_error(f"Error running listener: {e}")
            import traceback
            traceback.print_exc()
            self.listener_running = False

    def _wait_for_connection(self, timeout=None):
        """Wait for a connection to the listener"""
        if timeout is None:
            timeout = self.exploit_timeout if hasattr(self, 'exploit_timeout') else 60
        start_time = time.time()
        print_status(f"Waiting up to {timeout} seconds for connection...")
        
        # Track if we've seen a session to avoid false timeouts
        session_seen = False

        while time.time() - start_time < timeout:
            # Check if listener is still running
            if not self.listener_running:
                # Check if listener object says it's running (might be more accurate)
                if self.active_listener and hasattr(self.active_listener, 'running'):
                    if not self.active_listener.running:
                        print_warning("Listener stopped")
                        break
                else:
                    print_warning("Listener stopped")
                    break
            
            # Check if listener has received a connection/session
            if self.active_listener:
                # Check for sessions using multiple methods
                has_session = False
                
                # Method 1: Check has_session() method
                if hasattr(self.active_listener, 'has_session'):
                    has_session = self.active_listener.has_session()
                
                # Method 2: Check if there are any connections
                if not has_session and hasattr(self.active_listener, 'connections'):
                    has_session = len(self.active_listener.connections) > 0
                
                # Method 3: Check if there are any session connections
                if not has_session and hasattr(self.active_listener, '_session_connections'):
                    has_session = len(self.active_listener._session_connections) > 0
                
                if has_session:
                    if not session_seen:
                        print_success("Connection received!")
                        session_seen = True
                        self._session_received = True
                    # We have an active session - immediately exit the wait loop
                    return True

            time.sleep(1)

        if session_seen:
            self._session_received = True
            return True
        
        print_warning("Timeout waiting for connection")
        return False

    def _listener_has_active_sessions(self):
        """Check if the underlying listener currently maintains live sessions"""
        listener = self.active_listener
        if not listener:
            return False

        try:
            if hasattr(listener, 'has_session') and callable(listener.has_session):
                if listener.has_session():
                    return True
        except Exception:
            pass

        if hasattr(listener, 'connections') and getattr(listener, 'connections', None):
            if len(listener.connections) > 0:
                return True

        if hasattr(listener, '_session_connections') and getattr(listener, '_session_connections', None):
            if len(listener._session_connections) > 0:
                return True

        if hasattr(listener, 'session_count') and getattr(listener, 'session_count', 0) > 0:
            return True

        return False

    def _stop_listener(self):
        """Stop the active listener"""
        try:
            if self.listener_running:
                self.listener_running = False
                
                # Stop the active listener if it exists
                if self.active_listener and hasattr(self.active_listener, 'is_running') and self.active_listener.is_running():
                    self.active_listener.stop()
                
                # Wait for listener thread to finish
                if self.listener_thread and self.listener_thread.is_alive():
                    self.listener_thread.join(timeout=5)
                
                print_info("Listener stopped")
        except Exception as e:
            print_error(f"Error stopping listener: {e}")

    def get_listener_status(self):
        """Get the current status of the listener"""
        return {
            "running": self.listener_running,
            "module": self.listener_module,
            "config": self.listener_config,
            "payload_type": self.payload_type
        }

