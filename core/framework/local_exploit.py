#!/usr/bin/env python3
# -*- coding: utf-8 -*-

"""
Local exploit base class for executing exploits on established sessions.
Combines ExploitBase (payload/listener management) with session execution capabilities.
"""

from core.framework.exploit_base import ExploitBase
from core.framework.option.option_session import OptSession
from core.framework.failure import ProcedureError, FailureType
from core.output_handler import print_info, print_error, print_success, print_warning
from core.utils.function import pythonize_path
import importlib
import time
import socket


class LocalExploit(ExploitBase):
    """
    Base class for local exploit modules.
    Allows executing exploits on an established session with automatic payload/listener management.
    """

    TYPE_MODULE = "local_exploit"

    # Session option (in addition to payload from ExploitBase)
    session_id = OptSession("", "Session ID to use for local exploitation", required=True, advanced=False)

    def __init__(self, framework=None):
        super().__init__(framework)
        self._payload_type = None  # 'reverse' or 'bind'
    
    def check(self):
        """
        Check if the exploit can be executed on the target session.
        
        Returns:
            bool: True if the exploit can be executed, False otherwise
        """
        if not self.session_id.value:
            print_error("No session specified. Use 'set session_id <session_id>'")
            return False
        
        # Get session information
        session_info = self._get_session_info()
        if not session_info:
            print_error(f"Session {self.session_id.value} not found or not accessible")
            return False
        
        # Check if we can execute commands on the session
        try:
            test_output = self.cmd_execute("echo test")
            if not test_output:
                print_warning("Unable to execute commands on the session")
                return False
        except Exception as e:
            print_error(f"Error checking session: {str(e)}")
            return False
        
        print_success("Session is accessible and ready for local exploitation")
        return True
    
    def run(self):
        """
        Execute the local exploit.
        This method should be overridden by subclasses.
        
        Returns:
            bool: True if exploit executed successfully, False otherwise
        """
        raise NotImplementedError("LocalExploit modules must implement the run() method")
    
    def _exploit(self):
        """Execute the exploit with automatic listener management and session execution"""
        try:
            # Check session first
            if not self.check():
                return False
            
            # Require a payload to be set
            if not self.payload:
                print_error("No payload specified. Use 'set payload <path>' to set a payload.")
                return False
            
            # Extract listener information from payload
            listener_info = self._extract_listener_from_payload()
            if not listener_info:
                print_error("Failed to extract listener information from payload")
                return False
                
            self.listener_module = listener_info['listener']
            self.payload_type = listener_info['handler']
            self.session_type = listener_info.get('session_type', 'shell')
            self._payload_type = self.payload_type
            print_info(f"Using listener from payload: {self.listener_module}")
            print_info(f"Handler type: {self.payload_type}")
            
            # Start listener if needed (only if disablePayloadHandler is False)
            if not self.disablePayloadHandler:
                if not self._start_automatic_listener():
                    print_error("Failed to start listener")
                    return False
            
            # Run the actual exploit
            result = self.run()
            
            # Wait for connection if using reverse payload
            if self.payload_type == "reverse" and self.listener_running:
                print_info("Waiting for connection...")
                self._wait_for_connection()
            
            return result
            
        except ProcedureError as e:
            raise e
        except Exception as e:
            raise ProcedureError(FailureType.Unknown, e)
        finally:
            # Clean up listener if needed
            if self.listener_running:
                self._stop_listener()
    
    def _add_payload_option(self, payload_path):
        """
        Add payload options dynamically based on payload type.
        This method is called by OptPayload when payload is set.
        
        Args:
            payload_path: Path to the payload module
            
        Returns:
            payload_module: The loaded payload module instance, or None on error
        """
        try:
            payload_path_normalized = pythonize_path(payload_path)
            module_path = ".".join(("modules", payload_path_normalized))
            
            try:
                payload_module = getattr(importlib.import_module(module_path), "Module")(framework=self.framework)
                
                # Detect payload type from payload info
                payload_info = getattr(payload_module, '__info__', {})
                payload_type = payload_info.get('type', 'unknown')
                self._payload_type = payload_type.lower() if payload_type else 'unknown'
                
                # Remove old handler-specific options if they exist
                self._remove_handler_options()
                
                # Add handler-specific options based on payload type
                if self._payload_type == 'reverse':
                    self._add_reverse_options()
                elif self._payload_type == 'bind':
                    self._add_bind_options()
                
                # Copy other payload options to this module
                if hasattr(payload_module, 'exploit_attributes'):
                    from core.framework.option.option_string import OptString
                    from core.framework.option.option_integer import OptInteger
                    from core.framework.option.option_bool import OptBool
                    
                    for option_name, option_value in payload_module.exploit_attributes.items():
                        # Skip handler-specific options (we handle them separately)
                        if option_name in ['lhost', 'lport', 'rhost', 'rport']:
                            continue
                        
                        if not hasattr(self, option_name):
                            # Set default values from payload
                            if isinstance(option_value, (list, tuple)) and len(option_value) > 0:
                                default_value = option_value[0]
                                option_desc = option_value[2] if len(option_value) > 2 else ""
                                option_required = option_value[1] if len(option_value) > 1 else False
                                option_advanced = option_value[3] if len(option_value) > 3 else False
                                
                                # Create appropriate option type
                                if isinstance(default_value, int):
                                    opt = OptInteger(default_value, option_desc, option_required, option_advanced)
                                elif isinstance(default_value, bool):
                                    opt = OptBool(default_value, option_desc, option_required, option_advanced)
                                else:
                                    opt = OptString(str(default_value), option_desc, option_required, option_advanced)
                                
                                setattr(self, option_name, opt)
                                self.exploit_attributes[option_name] = option_value
                
                print_success(f"Payload loaded: {payload_path}")
                if self._payload_type != 'unknown':
                    print_info(f"Payload type: {self._payload_type}")
                    if self._payload_type == 'reverse':
                        print_info("Added options: lhost, lport")
                    elif self._payload_type == 'bind':
                        print_info("Added options: rhost, rport")
                
                return payload_module
                
            except ImportError as e:
                print_error(f"Failed to import payload module: {str(e)}")
                return None
            except Exception as e:
                print_error(f"Error loading payload: {str(e)}")
                return None
                
        except Exception as e:
            print_error(f"Error processing payload path: {str(e)}")
            return None
    
    def _add_reverse_options(self):
        """Add reverse payload options (lhost, lport)"""
        from core.framework.option.option_string import OptString
        from core.framework.option.option_integer import OptInteger
        
        # Add lhost option
        if not hasattr(self, 'lhost'):
            self.lhost = OptString("", "Local host IP address for reverse payload", required=True, advanced=False)
            self.exploit_attributes['lhost'] = ["", True, "Local host IP address for reverse payload", False]
        
        # Add lport option
        if not hasattr(self, 'lport'):
            self.lport = OptInteger(4444, "Local port for reverse payload", required=True, advanced=False)
            self.exploit_attributes['lport'] = [4444, True, "Local port for reverse payload", False]
    
    def _add_bind_options(self):
        """Add bind payload options (rhost, rport)"""
        from core.framework.option.option_string import OptString
        from core.framework.option.option_integer import OptInteger
        
        # Add rhost option
        if not hasattr(self, 'rhost'):
            self.rhost = OptString("", "Remote host IP address for bind payload", required=True, advanced=False)
            self.exploit_attributes['rhost'] = ["", True, "Remote host IP address for bind payload", False]
        
        # Add rport option
        if not hasattr(self, 'rport'):
            self.rport = OptInteger(4444, "Remote port for bind payload", required=True, advanced=False)
            self.exploit_attributes['rport'] = [4444, True, "Remote port for bind payload", False]
    
    def _remove_handler_options(self):
        """Remove handler-specific options when payload changes"""
        options_to_remove = ['lhost', 'lport', 'rhost', 'rport']
        for option_name in options_to_remove:
            if hasattr(self, option_name):
                delattr(self, option_name)
            if option_name in self.exploit_attributes:
                del self.exploit_attributes[option_name]
    
    def _get_session_info(self):
        """Get information about the current session"""
        if not self.framework or not hasattr(self.framework, 'session_manager'):
            return None
        
        session_id = self.session_id.value if hasattr(self.session_id, 'value') else str(self.session_id)
        if not session_id:
            return None
        
        try:
            # Try to get standard session
            session_data = self.framework.session_manager.get_session(session_id)
            if session_data:
                return {
                    'id': session_data.id,
                    'host': session_data.host,
                    'port': session_data.port,
                    'type': session_data.session_type,
                    'platform': getattr(session_data, 'platform', 'unknown')
                }
        except Exception:
            pass
        
        return None
    
    def _get_platform(self):
        """Get platform information from session"""
        session_info = self._get_session_info()
        if session_info:
            return session_info.get('platform', 'unknown')
        
        # Try to detect platform by executing commands
        return self._detect_platform()
    
    def _detect_platform(self):
        """Detect platform by executing system commands"""
        try:
            # Try Unix/Linux commands
            uname_output = self.cmd_execute("uname -s 2>/dev/null")
            if uname_output and uname_output.strip():
                uname = uname_output.strip().lower()
                if 'linux' in uname:
                    return 'linux'
                elif 'darwin' in uname or 'mac' in uname:
                    return 'macos'
                elif 'freebsd' in uname:
                    return 'freebsd'
            
            # Try Windows command
            ver_output = self.cmd_execute("ver 2>nul")
            if ver_output and ('windows' in ver_output.lower() or 'microsoft' in ver_output.lower()):
                return 'windows'
            
            # Try checking for common Windows paths
            win_path = self.cmd_execute("if exist C:\\Windows\\System32 echo windows 2>nul")
            if win_path and 'windows' in win_path.lower():
                return 'windows'
            
        except Exception as e:
            print_warning(f"Error detecting platform: {str(e)}")
        
        return 'unknown'
    
    def cmd_execute(self, command: str) -> str:
        """
        Execute a command on the session.
        
        Args:
            command: The command to execute
            
        Returns:
            str: The output of the command, or empty string if execution failed
        """
        # Check if framework is available
        if not self.framework:
            raise ProcedureError(FailureType.ConfigurationError, "Framework not available")
        
        # Check if session_id is set
        session_id_value = self.session_id.value if hasattr(self.session_id, 'value') else str(self.session_id)
        if not session_id_value:
            raise ProcedureError(FailureType.ConfigurationError, "Session ID not set")
        
        # Execute command using shell_manager
        if not hasattr(self.framework, 'shell_manager') or not self.framework.shell_manager:
            raise ProcedureError(FailureType.ConfigurationError, "Shell manager not available")
        
        result = self.framework.shell_manager.execute_command(session_id_value, command)
        
        # Check for errors
        if result.get('error'):
            return result.get('error', '')
        
        # Return the output
        return result.get('output', '')
    
    def cmd_exec(self, command: str) -> str:
        """
        Alias for cmd_execute for backward compatibility.
        
        Args:
            command: The command to execute
            
        Returns:
            str: The output of the command, or empty string if execution failed
        """
        return self.cmd_execute(command)
    
    def _check_if_port_busy(self, port):
        """Check if a port is already in use"""
        try:
            s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            s.settimeout(1)
            result = s.connect_ex(("127.0.0.1", int(port)))
            s.close()
            
            if result == 0:
                print_error(f"Port {port} is already in use. Please select another port.")
                return False
            
            return True
        except Exception as e:
            print_warning(f"Could not check port availability: {str(e)}")
            return True  # Assume port is available if check fails

