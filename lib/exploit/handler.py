#!/usr/bin/env python3
# -*- coding: utf-8 -*-

import platform
import socket
import time
from typing import Optional, Dict, Any, Tuple
import uuid

from core.framework.base_module import BaseModule
from core.framework.enums import SessionType
from core.output_handler import print_success, print_error, print_info, print_status, print_warning
from core.framework.option import OptString, OptPort


# Try to import paramiko for SSH
try:
    import paramiko
    PARAMIKO_AVAILABLE = True
except ImportError:
    PARAMIKO_AVAILABLE = False


class Handler(BaseModule):
    """
    Handler library for creating sessions from protocol connections
    Compatible with Windows, Linux, macOS, and other Unix-like systems
    """
    
    def __init__(self, framework=None):
        super().__init__(framework)
        self._platform = self._detect_platform()
    
    def _detect_platform(self) -> str:
        """Detect the current operating system"""
        system = platform.system().lower()
        if system == 'windows':
            return 'windows'
        elif system in ['linux', 'darwin'] or 'unix' in system:
            return 'unix'
        else:
            return 'unknown'
    
    def handler_ssh(self, connection, host: Optional[str] = None, port: Optional[int] = None, 
                    username: Optional[str] = None, additional_data: Optional[Dict[str, Any]] = None) -> Optional[str]:
        """
        Create an SSH session from an established SSH connection
        
        Args:
            connection: SSH connection object (paramiko SSHClient or similar)
            host: Target host IP or hostname (extracted from connection if not provided)
            port: Target port (extracted from connection if not provided)
            username: SSH username (extracted from connection if not provided)
            additional_data: Additional session metadata
            
        Returns:
            Session ID if successful, None otherwise
        """
        if not PARAMIKO_AVAILABLE:
            print_error("paramiko library not available. Install with: pip install paramiko")
            return None
        
        try:
            # Extract connection information
            if isinstance(connection, paramiko.SSHClient):
                # Get transport information
                transport = connection.get_transport()
                if transport:
                    sock = transport.getpeername()
                    if sock and not host:
                        host = sock[0]
                    if sock and not port:
                        port = sock[1]
                
                # Try to get username from connection
                if not username and hasattr(transport, 'username'):
                    username = transport.username
            
            # Fallback: use provided values or defaults
            if not host:
                host = getattr(self, 'target', 'unknown')
            if not port:
                port = getattr(self, 'port', 22)
            if not username:
                username = getattr(self, 'ssh_user', 'root')
            
            # Prepare session data
            session_data = {
                'session_type': SessionType.SSH.value if hasattr(SessionType.SSH, 'value') else 'ssh',
                'protocol': 'ssh',
                'username': username,
                'connection': connection,
                'platform': self._platform
            }
            
            # Add additional data if provided
            if additional_data:
                session_data.update(additional_data)
            
            # Create session via framework
            session_id = self._create_session(host, port, 'ssh', session_data)
            
            if session_id:
                print_success(f"SSH session created: {session_id}")
                print_info(f"Host: {host}:{port}")
                print_info(f"Username: {username}")
                print_info(f"Platform: {self._platform}")
                return session_id
            else:
                print_error("Failed to create SSH session")
                return None
                
        except Exception as e:
            print_error(f"Error creating SSH session: {e}")
            return None
    
    def handler_http(self, connection, host: Optional[str] = None, port: Optional[int] = None,
                     url: Optional[str] = None, additional_data: Optional[Dict[str, Any]] = None) -> Optional[str]:
        """
        Create an HTTP session from an established HTTP connection
        
        Args:
            connection: HTTP connection object (requests Session or similar)
            host: Target host IP or hostname
            port: Target port
            url: Full URL if available
            additional_data: Additional session metadata
            
        Returns:
            Session ID if successful, None otherwise
        """
        try:
            # Extract connection information
            if hasattr(connection, 'get'):
                # It's a requests Session
                if hasattr(connection, 'base_url'):
                    from urllib.parse import urlparse
                    parsed = urlparse(connection.base_url)
                    if not host:
                        host = parsed.hostname
                    if not port:
                        port = parsed.port or 80
            
            # Fallback: use provided values or defaults
            if not host:
                host = getattr(self, 'target', 'unknown')
            if not port:
                port = getattr(self, 'port', 80)
            
            # Prepare session data
            session_data = {
                'session_type': SessionType.HTTP.value if hasattr(SessionType.HTTP, 'value') else 'http',
                'protocol': 'http',
                'connection': connection,
                'url': url,
                'platform': self._platform
            }
            
            # Add additional data if provided
            if additional_data:
                session_data.update(additional_data)
            
            # Create session via framework
            session_id = self._create_session(host, port, 'http', session_data)
            
            if session_id:
                print_success(f"HTTP session created: {session_id}")
                print_info(f"Host: {host}:{port}")
                if url:
                    print_info(f"URL: {url}")
                return session_id
            else:
                print_error("Failed to create HTTP session")
                return None
                
        except Exception as e:
            print_error(f"Error creating HTTP session: {e}")
            return None
    
    def handler_tcp(self, connection, host: Optional[str] = None, port: Optional[int] = None,
                    additional_data: Optional[Dict[str, Any]] = None) -> Optional[str]:
        """
        Create a TCP session from an established TCP connection
        
        Args:
            connection: TCP socket connection
            host: Target host IP or hostname
            port: Target port
            additional_data: Additional session metadata
            
        Returns:
            Session ID if successful, None otherwise
        """
        try:
            # Extract connection information from socket
            if isinstance(connection, socket.socket):
                try:
                    peer = connection.getpeername()
                    if peer and not host:
                        host = peer[0]
                    if peer and not port:
                        port = peer[1]
                except:
                    pass
            
            # Fallback: use provided values or defaults
            if not host:
                host = getattr(self, 'target', 'unknown')
            if not port:
                port = getattr(self, 'port', 0)
            
            # Prepare session data
            session_data = {
                'session_type': SessionType.SHELL.value if hasattr(SessionType.SHELL, 'value') else 'shell',
                'protocol': 'tcp',
                'connection': connection,
                'platform': self._platform
            }
            
            # Add additional data if provided
            if additional_data:
                session_data.update(additional_data)
            
            # Create session via framework
            session_id = self._create_session(host, port, 'shell', session_data)
            
            if session_id:
                print_success(f"TCP session created: {session_id}")
                print_info(f"Host: {host}:{port}")
                return session_id
            else:
                print_error("Failed to create TCP session")
                return None
                
        except Exception as e:
            print_error(f"Error creating TCP session: {e}")
            return None
    
    def handler_generic(self, connection, session_type: str, host: Optional[str] = None, 
                       port: Optional[int] = None, additional_data: Optional[Dict[str, Any]] = None) -> Optional[str]:
        """
        Create a generic session from any connection type
        
        Args:
            connection: Connection object of any type
            session_type: Type of session (ssh, http, shell, etc.)
            host: Target host IP or hostname
            port: Target port
            additional_data: Additional session metadata
            
        Returns:
            Session ID if successful, None otherwise
        """
        try:
            # Fallback: use provided values or defaults
            if not host:
                host = getattr(self, 'target', 'unknown')
            if not port:
                port = getattr(self, 'port', 0)
            
            # Prepare session data
            session_data = {
                'session_type': session_type,
                'connection': connection,
                'platform': self._platform
            }
            
            # Add additional data if provided
            if additional_data:
                session_data.update(additional_data)
            
            # Create session via framework
            session_id = self._create_session(host, port, session_type, session_data)
            
            if session_id:
                print_success(f"Session created: {session_id}")
                print_info(f"Type: {session_type}")
                print_info(f"Host: {host}:{port}")
                return session_id
            else:
                print_error("Failed to create session")
                return None
                
        except Exception as e:
            print_error(f"Error creating session: {e}")
            return None
    
    def _create_session(self, host: str, port: int, session_type: str, data: Dict[str, Any]) -> Optional[str]:
        """
        Internal method to create a session via the framework's session manager
        
        Args:
            host: Target host
            port: Target port
            session_type: Type of session
            data: Session data dictionary
            
        Returns:
            Session ID if successful, None otherwise
        """
        try:
            # Check if framework and session_manager are available
            if not self.framework:
                print_error("Framework not available")
                return None
            
            if not hasattr(self.framework, 'session_manager'):
                print_error("Session manager not available")
                return None
            
            # Create session using session manager
            session_id = self.framework.session_manager.create_session(
                host=host,
                port=port,
                session_type=session_type,
                data=data
            )
            
            return session_id
            
        except Exception as e:
            print_error(f"Error in _create_session: {e}")
            return None
    
    def handler_execute(self, host: Optional[str] = None, port: Optional[int] = None,
                       session_type: str = "shell", additional_data: Optional[Dict[str, Any]] = None) -> bool:
        """
        Mark exploit as successful and optionally create a session for command execution
        
        This method is called when an exploit successfully executes commands on the target.
        It marks the target as vulnerable and can create a session if command execution
        can be maintained.
        
        Args:
            host: Target host IP or hostname (uses self.target if not provided)
            port: Target port (uses self.port if not provided)
            session_type: Type of session to create (default: "shell")
            additional_data: Additional session metadata
            
        Returns:
            True if successful, False otherwise
        """
        try:
            # Mark target as vulnerable
            from core.framework.checkcode import Vulnerable
            Vulnerable.SUCCESS()
            
            # Extract host and port if not provided
            if not host:
                host = getattr(self, 'target', 'unknown')
            if not port:
                port = getattr(self, 'port', 0)
            
            # Check if we have an execute method (for command execution exploits)
            if hasattr(self, 'execute'):
                print_success("Command execution verified")
                print_info(f"Target: {host}:{port}")
                print_info("You can use the 'execute' method to run commands on the target")
                
                # Optionally create a session for command execution exploits
                # This allows the framework to track the exploit session
                if self.framework and hasattr(self.framework, 'session_manager'):
                    session_data = {
                        'session_type': session_type,
                        'protocol': 'http',  # Most command execution exploits are via HTTP
                        'exploit_type': 'command_execution',
                        'has_execute_method': True,
                        'platform': self._platform
                    }
                    
                    # Add additional data if provided
                    if additional_data:
                        session_data.update(additional_data)
                    
                    # Create session
                    session_id = self._create_session(host, port, session_type, session_data)
                    if session_id:
                        print_success(f"Exploit session created: {session_id}")
                        return True
            
            return True
            
        except Exception as e:
            print_error(f"Error in handler_execute: {e}")
            return False
    
    def not_vulnerable(self):
        """Mark target as not vulnerable"""
        from core.framework.failure import fail
        fail.NotVulnerable()


class Reverse(Handler):
    """
    Mixin class for reverse shell handlers in post modules
    Provides start_handler() method to start a reverse TCP listener
    """
    lhost = OptString("", "Local host to listen on", True)
    lport = OptPort(4444, "Local port to listen on", True)
    
    def __init__(self, framework=None):
        super().__init__(framework)
        self._listener_thread = None
        self._listener_socket = None
    
    def start_handler(self):
        """Start a reverse TCP listener"""
        try:
            # Check if lhost and lport are set
            if not hasattr(self, 'lhost') or not self.lhost:
                print_error("lhost not set. Please set lhost option.")
                return False
            if not hasattr(self, 'lport') or not self.lport:
                print_error("lport not set. Please set lport option.")
                return False
            
            lhost = str(self.lhost.value) if hasattr(self.lhost, 'value') else str(self.lhost)
            lport = int(self.lport.value) if hasattr(self.lport, 'value') else int(self.lport)
            
            print_info(f"Starting reverse TCP handler on {lhost}:{lport}")
            
            # Create socket
            self._listener_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            self._listener_socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
            self._listener_socket.bind((lhost, lport))
            self._listener_socket.listen(5)
            self._listener_socket.settimeout(1.0)
            
            print_success(f"Listening on {lhost}:{lport}")
            print_info("Waiting for connection...")
            
            # Start listener in background thread
            import threading
            self._listener_thread = threading.Thread(target=self._accept_connections, daemon=True)
            self._listener_thread.start()
            
            return True
            
        except Exception as e:
            print_error(f"Failed to start reverse handler: {e}")
            return False
    
    def _accept_connections(self):
        """Accept connections in background thread"""
        try:
            while self._listener_socket:
                try:
                    client_socket, address = self._listener_socket.accept()
                    print_success(f"Connection received from {address[0]}:{address[1]}")
                    
                    # Create session from connection
                    session_data = {
                        'connection': client_socket,
                        'address': address,
                        'connection_time': time.time(),
                        'protocol': 'tcp',
                        'handler': 'reverse',
                        'connection_type': 'reverse'
                    }
                    
                    session_id = self._create_session(address[0], address[1], 'shell', session_data)
                    
                    if session_id:
                        print_success(f"Session {session_id} created")
                        # Store socket for session
                        if self.framework and hasattr(self.framework, 'session_manager'):
                            session = self.framework.session_manager.get_session(session_id)
                            if session:
                                session.data['socket'] = client_socket
                    else:
                        client_socket.close()
                        
                except socket.timeout:
                    continue
                except Exception as e:
                    if self._listener_socket:
                        print_error(f"Error accepting connection: {e}")
                    break
        except Exception as e:
            print_error(f"Listener thread error: {e}")
    
    def stop_handler(self):
        """Stop the reverse handler"""
        try:
            if self._listener_socket:
                self._listener_socket.close()
                self._listener_socket = None
        except Exception:
            pass


class Bind(Handler):
    """
    Mixin class for bind shell handlers in post modules
    Provides start_handler() method to connect to a bind TCP shell
    """

    rhost = OptString("", "Remote host where PHP bind shell is running", True)
    rport = OptPort(6666, "Remote port where PHP bind shell is listening", True)

    def start_handler(self):
        """Start a bind TCP handler (connect to remote bind shell)"""
        try:
            # Check if rhost and rport are set
            if not hasattr(self, 'rhost') or not self.rhost:
                print_error("rhost not set. Please set rhost option.")
                return False
            if not hasattr(self, 'rport') or not self.rport:
                print_error("rport not set. Please set rport option.")
                return False
            
            rhost = str(self.rhost.value) if hasattr(self.rhost, 'value') else str(self.rhost)
            rport = int(self.rport.value) if hasattr(self.rport, 'value') else int(self.rport)
            
            print_info(f"Connecting to bind shell at {rhost}:{rport}")
            
            # Connect to remote bind shell
            sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            sock.settimeout(10.0)
            sock.connect((rhost, rport))
            
            print_success(f"Connected to {rhost}:{rport}")
            
            # Create session from connection
            session_data = {
                'connection': sock,
                'address': (rhost, rport),
                'connection_time': time.time(),
                'protocol': 'tcp',
                'handler': 'bind',
                'connection_type': 'bind'
            }
            
            session_id = self._create_session(rhost, rport, 'shell', session_data)
            
            if session_id:
                print_success(f"Session {session_id} created")
                # Store socket for session
                if self.framework and hasattr(self.framework, 'session_manager'):
                    session = self.framework.session_manager.get_session(session_id)
                    if session:
                        session.data['socket'] = sock
                return True
            else:
                sock.close()
                return False
                
        except Exception as e:
            print_error(f"Failed to connect to bind shell: {e}")
            return False
