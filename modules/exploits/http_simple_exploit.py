#!/usr/bin/env python3
# -*- coding: utf-8 -*-

"""
HTTP Simple Exploit - Example exploit with automatic listener management
Author: KittySploit Team
Version: 1.0.0
"""

from kittysploit import *
from core.framework.exploit import Exploit
from core.framework.enums import Handler, SessionType
from core.framework.option.option_choice import OptChoice
from core.output_handler import print_info, print_success, print_error, print_warning
import requests
import time

class Module(Exploit):
    """Simple HTTP exploit demonstrating automatic listener management"""
    
    __info__ = {
        'name': 'HTTP Simple Exploit',
        'description': 'Simple HTTP exploit with automatic listener management',
        'author': 'KittySploit Team',
        'version': '1.0.0',
        'references': []
    }
    
    # Exploit-specific options
    target = OptString("127.0.0.1", "Target IP address", True)
    port = OptPort(80, "Target port", True)
    path = OptString("/", "Target path", False)
    method = OptChoice("GET", "HTTP method", False, ["GET", "POST", "PUT", "DELETE"])
    user_agent = OptString("Mozilla/5.0 (compatible; KittySploit)", "User-Agent", False)
    
    def check(self):
        """Check if the target is vulnerable"""
        try:
            print_info(f"Checking vulnerability on {self.target}:{self.port}")
            
            # Test if target is reachable
            try:
                url = f"http://{self.target}:{self.port}{self.path}"
                headers = {'User-Agent': self.user_agent}
                
                response = requests.get(url, headers=headers, timeout=10, allow_redirects=True)
                
                if response.status_code == 200:
                    print_success(f"Target is reachable (Status: {response.status_code})")
                    
                    # Check for common vulnerabilities
                    if self._check_common_vulnerabilities(response):
                        print_success("Target appears to be vulnerable")
                        return True
                    else:
                        print_warning("Target is reachable but no obvious vulnerabilities found")
                        return True  # For demo purposes, assume vulnerable
                else:
                    print_warning(f"Target returned status code: {response.status_code}")
                    return True  # For demo purposes, assume vulnerable
                    
            except requests.exceptions.ConnectionError:
                print_error("Target is not reachable")
                return False
            except Exception as e:
                print_error(f"Error checking target: {e}")
                return False
                
        except Exception as e:
            print_error(f"Vulnerability check failed: {e}")
            return False
    
    def _check_common_vulnerabilities(self, response):
        """Check for common web vulnerabilities"""
        try:
            # Check for common vulnerable headers
            vulnerable_headers = [
                'X-Powered-By',
                'Server',
                'X-AspNet-Version',
                'X-AspNetMvc-Version'
            ]
            
            for header in vulnerable_headers:
                if header in response.headers:
                    print_info(f"Found header: {header}: {response.headers[header]}")
            
            # Check for common vulnerable technologies
            content = response.text.lower()
            vulnerable_techs = [
                'php', 'asp', 'jsp', 'coldfusion', 'iis', 'apache', 'nginx'
            ]
            
            for tech in vulnerable_techs:
                if tech in content:
                    print_info(f"Detected technology: {tech}")
            
            return True
            
        except Exception as e:
            print_error(f"Error checking vulnerabilities: {e}")
            return False
    
    def run(self):
        """Run the exploit"""
        try:
            print_info(f"Exploiting {self.target}:{self.port}")
            print_info(f"Payload type: {self.payload_type}")
            print_info(f"Session type: {self.session_type}")
            print_info(f"HTTP method: {self.method}")
            
            if self.payload_type == "reverse":
                print_info(f"Reverse payload will connect to {self.lhost}:{self.lport}")
            elif self.payload_type == "bind":
                print_info(f"Bind payload will listen on {self.rhost}:{self.rport}")
            
            # Simulate exploit execution
            print_info("Executing exploit...")
            
            # Simulate HTTP request
            url = f"http://{self.target}:{self.port}{self.path}"
            headers = {'User-Agent': self.user_agent}
            
            print_info(f"Sending {self.method} request to {url}")
            
            # Simulate exploit delay
            time.sleep(2)
            
            # Simulate successful exploitation
            print_success("Exploit executed successfully!")
            print_info("Payload should connect to listener shortly...")
            
            # Simulate payload execution
            if self.payload_type == "reverse":
                print_info("Reverse payload executed, attempting to connect...")
            elif self.payload_type == "bind":
                print_info("Bind payload executed, waiting for connection...")
            
            return True
            
        except Exception as e:
            print_error(f"Exploit failed: {e}")
            return False
